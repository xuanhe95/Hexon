{"ast":null,"code":"/*!\n* tiptap-utils v1.13.0\n* (c) 2021 überdosis GbR (limited liability)\n* @license MIT\n*/\n\nimport { NodeSelection } from 'prosemirror-state';\nfunction createCell(cellType, cellContent) {\n  if (cellContent) {\n    return cellType.createChecked(null, cellContent);\n  }\n  return cellType.createAndFill();\n}\nfunction getTableNodeTypes(schema) {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes;\n  }\n  const roles = {};\n  Object.keys(schema.nodes).forEach(type => {\n    const nodeType = schema.nodes[type];\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType;\n    }\n  }); // eslint-disable-next-line\n\n  schema.cached.tableNodeTypes = roles;\n  return roles;\n}\nfunction createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {\n  const types = getTableNodeTypes(schema);\n  const headerCells = [];\n  const cells = [];\n  for (let index = 0; index < colsCount; index += 1) {\n    const cell = createCell(types.cell, cellContent);\n    if (cell) {\n      cells.push(cell);\n    }\n    if (withHeaderRow) {\n      const headerCell = createCell(types.header_cell, cellContent);\n      if (headerCell) {\n        headerCells.push(headerCell);\n      }\n    }\n  }\n  const rows = [];\n  for (let index = 0; index < rowsCount; index += 1) {\n    rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));\n  }\n  return types.table.createChecked(null, rows);\n}\nfunction equalNodeType(nodeType, node) {\n  return Array.isArray(nodeType) && nodeType.indexOf(node.type) > -1 || node.type === nodeType;\n}\nfunction flatten(node) {\n  // eslint-disable-next-line\n  const descend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  }\n  const result = []; // eslint-disable-next-line\n\n  node.descendants((child, pos) => {\n    result.push({\n      node: child,\n      pos\n    });\n    if (!descend) {\n      return false;\n    }\n  });\n  return result;\n}\nfunction findChildren(node, predicate, descend) {\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  } else if (!predicate) {\n    throw new Error('Invalid \"predicate\" parameter');\n  }\n  return flatten(node, descend).filter(child => predicate(child.node));\n}\nfunction findBlockNodes(node, descend) {\n  return findChildren(node, child => child.isBlock, descend);\n}\n\n// eslint-disable-next-line\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n}\nfunction findParentNode(predicate) {\n  return selection => findParentNodeClosestToPos(selection.$from, predicate);\n}\nfunction isNodeSelection(selection) {\n  return selection instanceof NodeSelection;\n}\nfunction findSelectedNodeOfType(nodeType) {\n  // eslint-disable-next-line\n  return function (selection) {\n    if (isNodeSelection(selection)) {\n      const {\n        node\n      } = selection;\n      const {\n        $from\n      } = selection;\n      if (equalNodeType(nodeType, node)) {\n        return {\n          node,\n          pos: $from.pos,\n          depth: $from.depth\n        };\n      }\n    }\n  };\n}\nfunction getMarkAttrs(state, type) {\n  const {\n    from,\n    to\n  } = state.selection;\n  let marks = [];\n  state.doc.nodesBetween(from, to, node => {\n    marks = [...marks, ...node.marks];\n  });\n  const mark = marks.find(markItem => markItem.type.name === type.name);\n  if (mark) {\n    return mark.attrs;\n  }\n  return {};\n}\nfunction getMarkRange() {\n  let $pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (!$pos || !type) {\n    return false;\n  }\n  const start = $pos.parent.childAfter($pos.parentOffset);\n  if (!start.node) {\n    return false;\n  }\n  const link = start.node.marks.find(mark => mark.type === type);\n  if (!link) {\n    return false;\n  }\n  let startIndex = $pos.index();\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n  while (startIndex > 0 && link.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n  while (endIndex < $pos.parent.childCount && link.isInSet($pos.parent.child(endIndex).marks)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\nfunction getNodeAttrs(state, type) {\n  const {\n    from,\n    to\n  } = state.selection;\n  let nodes = [];\n  state.doc.nodesBetween(from, to, node => {\n    nodes = [...nodes, node];\n  });\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name);\n  if (node) {\n    return node.attrs;\n  }\n  return {};\n}\nfunction markIsActive(state, type) {\n  const {\n    from,\n    $from,\n    to,\n    empty\n  } = state.selection;\n  if (empty) {\n    return !!type.isInSet(state.storedMarks || $from.marks());\n  }\n  return !!state.doc.rangeHasMark(from, to, type);\n}\nfunction nodeEqualsType(_ref) {\n  let {\n    types,\n    node\n  } = _ref;\n  return Array.isArray(types) && types.includes(node.type) || node.type === types;\n}\nfunction nodeIsActive(state, type) {\n  let attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const predicate = node => node.type === type;\n  const node = findSelectedNodeOfType(type)(state.selection) || findParentNode(predicate)(state.selection);\n  if (!Object.keys(attrs).length || !node) {\n    return !!node;\n  }\n  return node.node.hasMarkup(type, {\n    ...node.node.attrs,\n    ...attrs\n  });\n}\nexport { createCell, createTable, equalNodeType, findBlockNodes, findChildren, findParentNode, findParentNodeClosestToPos, findSelectedNodeOfType, flatten, getMarkAttrs, getMarkRange, getNodeAttrs, getTableNodeTypes, isNodeSelection, markIsActive, nodeEqualsType, nodeIsActive };","map":{"version":3,"names":["NodeSelection","createCell","cellType","cellContent","createChecked","createAndFill","getTableNodeTypes","schema","cached","tableNodeTypes","roles","Object","keys","nodes","forEach","type","nodeType","spec","tableRole","createTable","rowsCount","colsCount","withHeaderRow","types","headerCells","cells","index","cell","push","headerCell","header_cell","rows","row","table","equalNodeType","node","Array","isArray","indexOf","flatten","descend","arguments","length","undefined","Error","result","descendants","child","pos","findChildren","predicate","filter","findBlockNodes","isBlock","findParentNodeClosestToPos","$pos","i","depth","before","start","findParentNode","selection","$from","isNodeSelection","findSelectedNodeOfType","getMarkAttrs","state","from","to","marks","doc","nodesBetween","mark","find","markItem","name","attrs","getMarkRange","parent","childAfter","parentOffset","link","startIndex","startPos","offset","endIndex","endPos","nodeSize","isInSet","childCount","getNodeAttrs","reverse","nodeItem","markIsActive","empty","storedMarks","rangeHasMark","nodeEqualsType","_ref","includes","nodeIsActive","hasMarkup"],"sources":["/Users/xander/go/hexon/frontend/node_modules/tiptap-utils/dist/utils.esm.js"],"sourcesContent":["\n    /*!\n    * tiptap-utils v1.13.0\n    * (c) 2021 überdosis GbR (limited liability)\n    * @license MIT\n    */\n  \nimport { NodeSelection } from 'prosemirror-state';\n\nfunction createCell(cellType, cellContent) {\n  if (cellContent) {\n    return cellType.createChecked(null, cellContent);\n  }\n\n  return cellType.createAndFill();\n}\n\nfunction getTableNodeTypes(schema) {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes;\n  }\n\n  const roles = {};\n  Object.keys(schema.nodes).forEach(type => {\n    const nodeType = schema.nodes[type];\n\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType;\n    }\n  }); // eslint-disable-next-line\n\n  schema.cached.tableNodeTypes = roles;\n  return roles;\n}\n\nfunction createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {\n  const types = getTableNodeTypes(schema);\n  const headerCells = [];\n  const cells = [];\n\n  for (let index = 0; index < colsCount; index += 1) {\n    const cell = createCell(types.cell, cellContent);\n\n    if (cell) {\n      cells.push(cell);\n    }\n\n    if (withHeaderRow) {\n      const headerCell = createCell(types.header_cell, cellContent);\n\n      if (headerCell) {\n        headerCells.push(headerCell);\n      }\n    }\n  }\n\n  const rows = [];\n\n  for (let index = 0; index < rowsCount; index += 1) {\n    rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));\n  }\n\n  return types.table.createChecked(null, rows);\n}\n\nfunction equalNodeType(nodeType, node) {\n  return Array.isArray(nodeType) && nodeType.indexOf(node.type) > -1 || node.type === nodeType;\n}\n\nfunction flatten(node) {\n  // eslint-disable-next-line\n  const descend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  }\n\n  const result = []; // eslint-disable-next-line\n\n  node.descendants((child, pos) => {\n    result.push({\n      node: child,\n      pos\n    });\n\n    if (!descend) {\n      return false;\n    }\n  });\n  return result;\n}\n\nfunction findChildren(node, predicate, descend) {\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  } else if (!predicate) {\n    throw new Error('Invalid \"predicate\" parameter');\n  }\n\n  return flatten(node, descend).filter(child => predicate(child.node));\n}\n\nfunction findBlockNodes(node, descend) {\n  return findChildren(node, child => child.isBlock, descend);\n}\n\n// eslint-disable-next-line\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i);\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n}\n\nfunction findParentNode(predicate) {\n  return selection => findParentNodeClosestToPos(selection.$from, predicate);\n}\n\nfunction isNodeSelection(selection) {\n  return selection instanceof NodeSelection;\n}\n\nfunction findSelectedNodeOfType(nodeType) {\n  // eslint-disable-next-line\n  return function (selection) {\n    if (isNodeSelection(selection)) {\n      const {\n        node\n      } = selection;\n      const {\n        $from\n      } = selection;\n\n      if (equalNodeType(nodeType, node)) {\n        return {\n          node,\n          pos: $from.pos,\n          depth: $from.depth\n        };\n      }\n    }\n  };\n}\n\nfunction getMarkAttrs(state, type) {\n  const {\n    from,\n    to\n  } = state.selection;\n  let marks = [];\n  state.doc.nodesBetween(from, to, node => {\n    marks = [...marks, ...node.marks];\n  });\n  const mark = marks.find(markItem => markItem.type.name === type.name);\n\n  if (mark) {\n    return mark.attrs;\n  }\n\n  return {};\n}\n\nfunction getMarkRange($pos = null, type = null) {\n  if (!$pos || !type) {\n    return false;\n  }\n\n  const start = $pos.parent.childAfter($pos.parentOffset);\n\n  if (!start.node) {\n    return false;\n  }\n\n  const link = start.node.marks.find(mark => mark.type === type);\n\n  if (!link) {\n    return false;\n  }\n\n  let startIndex = $pos.index();\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n\n  while (startIndex > 0 && link.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n\n  while (endIndex < $pos.parent.childCount && link.isInSet($pos.parent.child(endIndex).marks)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\n\nfunction getNodeAttrs(state, type) {\n  const {\n    from,\n    to\n  } = state.selection;\n  let nodes = [];\n  state.doc.nodesBetween(from, to, node => {\n    nodes = [...nodes, node];\n  });\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name);\n\n  if (node) {\n    return node.attrs;\n  }\n\n  return {};\n}\n\nfunction markIsActive(state, type) {\n  const {\n    from,\n    $from,\n    to,\n    empty\n  } = state.selection;\n\n  if (empty) {\n    return !!type.isInSet(state.storedMarks || $from.marks());\n  }\n\n  return !!state.doc.rangeHasMark(from, to, type);\n}\n\nfunction nodeEqualsType({\n  types,\n  node\n}) {\n  return Array.isArray(types) && types.includes(node.type) || node.type === types;\n}\n\nfunction nodeIsActive(state, type, attrs = {}) {\n  const predicate = node => node.type === type;\n\n  const node = findSelectedNodeOfType(type)(state.selection) || findParentNode(predicate)(state.selection);\n\n  if (!Object.keys(attrs).length || !node) {\n    return !!node;\n  }\n\n  return node.node.hasMarkup(type, { ...node.node.attrs,\n    ...attrs\n  });\n}\n\nexport { createCell, createTable, equalNodeType, findBlockNodes, findChildren, findParentNode, findParentNodeClosestToPos, findSelectedNodeOfType, flatten, getMarkAttrs, getMarkRange, getNodeAttrs, getTableNodeTypes, isNodeSelection, markIsActive, nodeEqualsType, nodeIsActive };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}