{"ast":null,"code":"// src/index.ts\nimport { Plugin as Plugin2 } from \"prosemirror-state\";\n\n// src/cellselection.ts\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport { NodeSelection as NodeSelection2, Selection, SelectionRange, TextSelection } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n  let cache = /* @__PURE__ */new WeakMap();\n  readFromCache = key => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = key => {\n    for (let i = 0; i < cache.length; i += 2) if (cache[i] == key) return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\nvar TableMap = class {\n  constructor(width, height, map, problems) {\n    this.width = width;\n    this.height = height;\n    this.map = map;\n    this.problems = problems;\n  }\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos) continue;\n      const left = i % this.width;\n      const top = i / this.width | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\n        bottom++;\n      }\n      return {\n        left,\n        top,\n        right,\n        bottom\n      };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    const {\n      left,\n      right,\n      top,\n      bottom\n    } = this.findCell(pos);\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width) return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB)\n    };\n  }\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    const result = [];\n    const seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0;; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        while (index < rowEndIndex && this.map[index] < rowStart) index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n};\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\") throw new RangeError(\"Not a table node: \" + table.type.name);\n  const width = findWidth(table),\n    height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems = null;\n  const colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0;; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n      if (i == rowNode.childCount) break;\n      const cellNode = rowNode.child(i);\n      const {\n        colspan,\n        rowspan,\n        colwidth\n      } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) map[start + w] = pos;else (problems || (problems = [])).push({\n            type: \"collision\",\n            row,\n            pos,\n            n: colspan - w\n          });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = (start + w) % width * 2,\n              prev = colWidths[widthIndex];\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n    if (missing) (problems || (problems = [])).push({\n      type: \"missing\",\n      row,\n      n: missing\n    });\n    pos++;\n  }\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2) if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n  if (badWidths) findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\nfunction findWidth(table) {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan) for (let j = 0; j < row; j++) {\n      const prevRow = table.child(j);\n      for (let i = 0; i < prevRow.childCount; i++) {\n        const cell = prevRow.child(i);\n        if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n      }\n    }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1) hasRowSpan = true;\n    }\n    if (width == -1) width = rowWidth;else if (width != rowWidth) width = Math.max(width, rowWidth);\n  }\n  return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) map.problems = [];\n  const seen = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos]) continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    let updated = null;\n    const attrs = node.attrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth)) (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated) map.problems.unshift({\n      type: \"colwidth mismatch\",\n      pos,\n      colwidth: updated\n    });\n  }\n}\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) return attrs.colwidth.slice();\n  const result = [];\n  for (let i = 0; i < attrs.colspan; i++) result.push(0);\n  return result;\n}\n\n// src/util.ts\nimport { PluginKey } from \"prosemirror-state\";\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n  if (typeof dom === \"string\") {\n    return {};\n  }\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map(s => Number(s)) : null;\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  const result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n  const attrs = {};\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth) attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter) setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\nfunction tableNodes(options) {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs = {\n    colspan: {\n      default: 1\n    },\n    rowspan: {\n      default: 1\n    },\n    colwidth: {\n      default: null\n    }\n  };\n  for (const prop in extraAttrs) cellAttrs[prop] = {\n    default: extraAttrs[prop].default\n  };\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{\n        tag: \"table\"\n      }],\n      toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{\n        tag: \"tr\"\n      }],\n      toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [{\n        tag: \"td\",\n        getAttrs: dom => getCellAttrs(dom, extraAttrs)\n      }],\n      toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [{\n        tag: \"th\",\n        getAttrs: dom => getCellAttrs(dom, extraAttrs)\n      }],\n      toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name],\n        role = type.spec.tableRole;\n      if (role) result[role] = type;\n    }\n  }\n  return result;\n}\n\n// src/util.ts\nvar tableEditingKey = new PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--) if ($pos.node(d).type.spec.tableRole == \"row\") return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === \"header_cell\") return $pos.node(d);\n  }\n  return null;\n}\nfunction isInTable(state) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--) if ($head.node(d).type.spec.tableRole == \"row\") return true;\n  return false;\n}\nfunction selectionCell(state) {\n  const sel = state.selection;\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    const role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos);\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    const role = before.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos) {\n  let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const result = {\n    ...attrs,\n    colspan: attrs.colspan - n\n  };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some(w => w > 0)) result.colwidth = null;\n  }\n  return result;\n}\nfunction addColSpan(attrs, pos) {\n  let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const result = {\n    ...attrs,\n    colspan: attrs.colspan + n\n  };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++) if (table.nodeAt(map.map[col + row * map.width]).type != headerCell) return false;\n  return true;\n}\n\n// src/cellselection.ts\nvar CellSelection = class extends Selection {\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell) {\n    let $headCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchorCell;\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween($anchorCell.pos - tableStart, $headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    const cells = map.cellsInRect(rect).filter(p => p != $headCell.pos - tableStart);\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map(pos => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new SelectionRange(doc.resolve(from), doc.resolve(from + cell.content.size));\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n  map(doc, mapping) {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection()) return CellSelection.rowSelection($anchorCell, $headCell);else if (tableChanged && this.isColSelection()) return CellSelection.colSelection($anchorCell, $headCell);else return new CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const rect = map.rectBetween(this.$anchorCell.pos - tableStart, this.$headCell.pos - tableStart);\n    const seen = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        const pos = map.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw RangeError(`No cell with offset ${pos} found`);\n        }\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight);\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw RangeError(`Could not create cell with attrs ${JSON.stringify(attrs)}`);\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs);\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n  replace(tr) {\n    let content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Slice.empty;\n    const mapFrom = tr.steps.length,\n      ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const {\n          $from,\n          $to\n        } = ranges[i],\n        mapping = tr.mapping.slice(mapFrom);\n      tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n    }\n    const sel = Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);\n    if (sel) tr.setSelection(sel);\n  }\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n  forEachCell(f) {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - tableStart, this.$headCell.pos - tableStart));\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\n    }\n  }\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) return false;\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n  }\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell) {\n    let $headCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchorCell;\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0) $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height) $headCell = doc.resolve(tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]);\n    } else {\n      if (headRect.top > 0) $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height) $anchorCell = doc.resolve(tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]);\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0) return false;\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n  eq(other) {\n    return other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell) {\n    let $headCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchorCell;\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0) $anchorCell = doc.resolve(tableStart + map.map[anchorRect.top * map.width]);\n      if (headRect.right < map.width) $headCell = doc.resolve(tableStart + map.map[map.width * (headRect.top + 1) - 1]);\n    } else {\n      if (headRect.left > 0) $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width) $anchorCell = doc.resolve(tableStart + map.map[map.width * (anchorRect.top + 1) - 1]);\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n  toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n  static fromJSON(doc, json) {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchorCell) {\n    let headCell = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : anchorCell;\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n};\nCellSelection.prototype.visible = false;\nSelection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    const $anchorCell = doc.resolve(this.anchor),\n      $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell)) return new CellSelection($anchorCell, $headCell);else return Selection.near($headCell, 1);\n  }\n};\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) return null;\n  const cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(Decoration.node(pos, pos + node.nodeSize, {\n      class: \"selectedCell\"\n    }));\n  });\n  return DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection(_ref) {\n  let {\n    $from,\n    $to\n  } = _ref;\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) return false;\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++) if ($from.after(depth + 1) < $from.end(depth)) break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--) if ($to.before(d + 1) > $to.start(d)) break;\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells(_ref2) {\n  let {\n    $from,\n    $to\n  } = _ref2;\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize;\n  let role;\n  if (sel instanceof NodeSelection2 && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// src/fixtables.ts\nimport { PluginKey as PluginKey2 } from \"prosemirror-state\";\nvar fixTablesKey = new PluginKey2(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n  const oldSize = old.childCount,\n    curSize = cur.childCount;\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    const child = cur.child(i);\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child)) changedDescendants(old.child(j), child, offset + 1, f);else child.nodesBetween(0, child.content.size, f, offset + 1);\n    offset += child.nodeSize;\n  }\n}\nfunction fixTables(state, oldState) {\n  let tr;\n  const check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\") tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState) state.doc.descendants(check);else if (oldState.doc != state.doc) changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n  const map = TableMap.get(table);\n  if (!map.problems) return tr;\n  if (!tr) tr = state.tr;\n  const mustAdd = [];\n  for (let i = 0; i < map.height; i++) mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == \"collision\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      const attrs = cell.attrs;\n      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(attrs, attrs.colspan - prob.n, prob.n));\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n\n      });\n    } else if (prob.type == \"colwidth mismatch\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth\n      });\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++) if (mustAdd[i]) {\n    if (first == null) first = i;\n    last = i;\n  }\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role = \"cell\";\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n        if (node) nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, {\n    fixTables: true\n  });\n}\n\n// src/input.ts\nimport { Fragment as Fragment3, Slice as Slice3 } from \"prosemirror-model\";\nimport { Selection as Selection2, TextSelection as TextSelection2 } from \"prosemirror-state\";\nimport { keydownHandler } from \"prosemirror-keymap\";\n\n// src/copypaste.ts\nimport { Fragment as Fragment2, Slice as Slice2 } from \"prosemirror-model\";\nimport { Transform } from \"prosemirror-transform\";\nfunction pastedCells(slice) {\n  if (!slice.size) return null;\n  let {\n    content,\n    openStart,\n    openEnd\n  } = slice;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema,\n    rows = [];\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right) cells = fitSlice(tableNodeTypes(schema).row, new Slice2(cells, left, right)).content;\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice2(content, openStart, openEnd)).content : content);\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n  const widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const {\n        rowspan,\n        colspan\n      } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++) widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(Fragment2.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill();\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(Fragment2.from(cells));\n    }\n  }\n  return {\n    height: rows.length,\n    width,\n    rows\n  };\n}\nfunction fitSlice(nodeType, slice) {\n  const node = nodeType.createAndFill();\n  const tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\nfunction clipCells(_ref3, newWidth, newHeight) {\n  let {\n    width,\n    height,\n    rows\n  } = _ref3;\n  if (width != newWidth) {\n    const added = [];\n    const newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row],\n        cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth) cell = cell.type.createChecked(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++) added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [],\n        source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight) cell = cell.type.create({\n          ...cell.attrs,\n          rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n        }, cell.content);\n        cells.push(cell);\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n  return {\n    width,\n    height,\n    rows\n  };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells = [];\n      let add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell) add = empty || (empty = types.cell.createAndFill());else add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++) cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n      cells.push(header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill()));\n    }\n    const emptyRow = types.row.create(null, Fragment2.from(cells)),\n      rows = [];\n    for (let i = map.height; i < height; i++) rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col,\n      pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const {\n        top: cellTop,\n        left: cellLeft\n      } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop\n      });\n      tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)), cell.type.createAndFill({\n        ...cell.attrs,\n        rowspan: cellTop + cell.attrs.rowspan - top\n      }));\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left,\n      pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)));\n      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)));\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error(\"No table found\");\n  }\n  let map = TableMap.get(table);\n  const {\n    top,\n    left\n  } = rect;\n  const right = left + cells.width,\n    bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error(\"No table found\");\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) recomp();\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table),\n      to = map.positionAt(row, right, table);\n    tr.replace(tr.mapping.slice(mapFrom).map(from + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart), new Slice2(cells.rows[row - top], 0, 0));\n  }\n  recomp();\n  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map.positionAt(top, left, table)), tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))));\n  dispatch(tr);\n}\n\n// src/input.ts\nvar handleKeyDown = keydownHandler({\n  ArrowLeft: arrow(\"horiz\", -1),\n  ArrowRight: arrow(\"horiz\", 1),\n  ArrowUp: arrow(\"vert\", -1),\n  ArrowDown: arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  Backspace: deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  Delete: deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(state, dispatch, Selection2.near(sel.$headCell, dir));\n    }\n    if (axis != \"horiz\" && !sel.empty) return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null) return false;\n    if (axis == \"horiz\") {\n      return maybeSetSelection(state, dispatch, Selection2.near(state.doc.resolve(sel.head + dir), dir));\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next) newSel = Selection2.near($next, 1);else if (dir < 0) newSel = Selection2.near(state.doc.resolve($cell.before(-1)), -1);else newSel = Selection2.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    let cellSel;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null) return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head) return false;\n    return maybeSetSelection(state, dispatch, new CellSelection(cellSel.$anchorCell, $head));\n  };\n}\nfunction deleteCellSelection(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent)) tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1), new Slice3(baseContent, 0, 0));\n    });\n    if (tr.docChanged) dispatch(tr);\n  }\n  return true;\n}\nfunction handleTripleClick(view, pos) {\n  const doc = view.state.doc,\n    $cell = cellAround(doc.resolve(pos));\n  if (!$cell) return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells) cells = {\n      width: 1,\n      height: 1,\n      rows: [Fragment3.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))]\n    };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start, sel.$headCell.pos - start);\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(view.state, view.dispatch, start, TableMap.get($cell.node(-1)).findCell($cell.pos - start), cells);\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown(view, startEvent) {\n  var _a;\n  if (startEvent.ctrlKey || startEvent.metaKey) return;\n  const startDOMCell = domInCell(view, startEvent.target);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    return;\n  }\n  function setCellSelection($anchor2, event) {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor2, $head)) {\n      if (starting) $head = $anchor2;else return;\n    }\n    const selection = new CellSelection($anchor2, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting) tr.setMeta(tableEditingKey, $anchor2.pos);\n      view.dispatch(tr);\n    }\n  }\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (tableEditingKey.getState(view.state) != null) view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n  function move(_event) {\n    const event = _event;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor2;\n    if (anchor != null) {\n      $anchor2 = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      $anchor2 = cellUnderMouse(view, startEvent);\n      if (!$anchor2) return stop();\n    }\n    if ($anchor2) setCellSelection($anchor2, event);\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection2)) return null;\n  const {\n    $head\n  } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d),\n      index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      const cellPos = $head.before(d);\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n  return null;\n}\nfunction cellUnderMouse(view, event) {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos) return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// src/columnresizing.ts\nimport { Plugin, PluginKey as PluginKey3 } from \"prosemirror-state\";\nimport { Decoration as Decoration2, DecorationSet as DecorationSet2 } from \"prosemirror-view\";\n\n// src/tableview.ts\nvar TableView = class {\n  constructor(node, cellMinWidth) {\n    this.node = node;\n    this.cellMinWidth = cellMinWidth;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"tableWrapper\";\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n    updateColumnsOnResize(node, this.colgroup, this.table, cellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n  }\n  update(node) {\n    if (node.type != this.node.type) return false;\n    this.node = node;\n    updateColumnsOnResize(node, this.colgroup, this.table, this.cellMinWidth);\n    return true;\n  }\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n};\nfunction updateColumnsOnResize(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  var _a;\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  if (!row) return;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const {\n      colspan,\n      colwidth\n    } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth) fixedWidth = false;\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth) nextDOM.style.width = cssWidth;\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\n// src/columnresizing.ts\nvar columnResizingPluginKey = new PluginKey3(\"tableColumnResizing\");\nfunction columnResizing() {\n  let {\n    handleWidth = 5,\n    cellMinWidth = 25,\n    View = TableView,\n    lastColumnResizable = true\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const plugin = new Plugin({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        plugin.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (node, view) => new View(node, cellMinWidth, view);\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: state => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1 ? {\n          class: \"resize-cursor\"\n        } : {};\n      },\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable);\n        },\n        mouseleave: view => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown2(view, event, cellMinWidth);\n        }\n      },\n      decorations: state => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\nvar ResizeState = class {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n  apply(tr) {\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null) return new ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== void 0) return new ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n};\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState) return;\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target);\n    let cell = -1;\n    if (target) {\n      const {\n        left,\n        right\n      } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth) cell = edgeCell(view, event, \"left\", handleWidth);else if (right - event.clientX <= handleWidth) cell = edgeCell(view, event, \"right\", handleWidth);\n    }\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n      updateHandle(view, cell);\n    }\n  }\n}\nfunction handleMouseLeave(view) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging) updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging) return false;\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, {\n    setDragging: {\n      startX: event.clientX,\n      startWidth: width\n    }\n  }));\n  function finish(event2) {\n    window.removeEventListener(\"mouseup\", finish);\n    window.removeEventListener(\"mousemove\", move);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n      updateColumnWidth(view, pluginState2.activeHandle, draggedWidth(pluginState2.dragging, event2, cellMinWidth));\n      view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, {\n        setDragging: null\n      }));\n    }\n  }\n  function move(event2) {\n    if (!event2.which) return finish(event2);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (!pluginState2) return;\n    if (pluginState2.dragging) {\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n      displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);\n    }\n  }\n  window.addEventListener(\"mouseup\", finish);\n  window.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\nfunction currentColWidth(view, cellPos, _ref4) {\n  let {\n    colspan,\n    colwidth\n  } = _ref4;\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width) return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth,\n    parts = colspan;\n  if (colwidth) {\n    for (let i = 0; i < colspan; i++) if (colwidth[i]) {\n      domWidth -= colwidth[i];\n      parts--;\n    }\n  }\n  return domWidth / parts;\n}\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\") target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  return target;\n}\nfunction edgeCell(view, event, side, handleWidth) {\n  const offset = side == \"right\" ? -handleWidth : handleWidth;\n  const found = view.posAtCoords({\n    left: event.clientX + offset,\n    top: event.clientY\n  });\n  if (!found) return -1;\n  const {\n    pos\n  } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) return -1;\n  if (side == \"right\") return $cell.pos;\n  const map = TableMap.get($cell.node(-1)),\n    start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n  view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, {\n    setHandle: value\n  }));\n}\nfunction updateColumnWidth(view, cell, width) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1),\n    map = TableMap.get(table),\n    start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos).attrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, {\n      ...attrs,\n      colwidth\n    });\n  }\n  if (tr.docChanged) view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1),\n    start = $cell.start(-1);\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n  if (!dom) return;\n  updateColumnsOnResize(table, dom.firstChild, dom, cellMinWidth, col, width);\n}\nfunction zeroes(n) {\n  return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet2.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width - 1;\n    if ((col == map.width || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      const dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      decorations.push(Decoration2.widget(pos, dom));\n    }\n  }\n  return DecorationSet2.create(state.doc, decorations);\n}\n\n// src/commands.ts\nimport { Fragment as Fragment4 } from \"prosemirror-model\";\nimport { TextSelection as TextSelection3 } from \"prosemirror-state\";\nfunction selectedRect(state) {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect = sel instanceof CellSelection ? map.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart) : map.findCell($pos.pos - tableStart);\n  return {\n    ...rect,\n    tableStart,\n    map,\n    table\n  };\n}\nfunction addColumn(tr, _ref5, col) {\n  let {\n    map,\n    tableStart,\n    table\n  } = _ref5;\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos);\n      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map.colCount(pos)));\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\nfunction removeColumn(tr, _ref6, col) {\n  let {\n    map,\n    table,\n    tableStart\n  } = _ref6;\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height;) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos);\n    const attrs = cell.attrs;\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null, removeColSpan(attrs, col - map.colCount(pos)));\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) return false;\n    for (let i = rect.right - 1;; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  var _a;\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++) if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell) return false;\n  return true;\n}\nfunction addRow(tr, _ref7, row) {\n  let {\n    map,\n    tableStart,\n    table\n  } = _ref7;\n  var _a;\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow)) refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n      const node = type == null ? void 0 : type.createAndFill();\n      if (node) cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\nfunction removeRow(tr, _ref8, row) {\n  let {\n    map,\n    table,\n    tableStart\n  } = _ref8;\n  let rowPos = 0;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n    if (row > 0 && pos == map.map[index - map.width]) {\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.width && pos == map.map[index + map.width]) {\n      const cell = table.nodeAt(pos);\n      const attrs = cell.attrs;\n      const copy = cell.type.create({\n        ...attrs,\n        rowspan: cell.attrs.rowspan - 1\n      }, cell.content);\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state),\n      tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n    for (let i = rect.bottom - 1;; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction isEmpty(cell) {\n  const c = cell.content;\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle(_ref9, rect) {\n  let {\n    width,\n    height,\n    map\n  } = _ref9;\n  let indexTop = rect.top * width + rect.left,\n    indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left,\n    indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1]) return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width]) return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\nfunction mergeCells(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) return false;\n  const rect = selectedRect(state),\n    {\n      map\n    } = rect;\n  if (cellsOverlapRectangle(map, rect)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen = {};\n    let content = Fragment4.empty;\n    let mergedPos;\n    let mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell) continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, rect.right - rect.left - mergedCell.attrs.colspan),\n      rowspan: rect.bottom - rect.top\n    });\n    if (content.size) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));\n    dispatch(tr);\n  }\n  return true;\n}\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(_ref10 => {\n    let {\n      node\n    } = _ref10;\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    var _a;\n    const sel = state.selection;\n    let cellNode;\n    let cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) return false;\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) baseAttrs = {\n        ...baseAttrs,\n        rowspan: 1\n      };\n      if (baseAttrs.colspan > 1) baseAttrs = {\n        ...baseAttrs,\n        colspan: 1\n      };\n      const rect = selectedRect(state),\n        tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++) attrs.push(colwidth ? {\n        ...baseAttrs,\n        colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n      } : baseAttrs);\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue;\n          tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({\n            node: cellNode,\n            row,\n            col\n          }).createAndFill(attrs[i]));\n        }\n      }\n      tr.setNodeMarkup(cellPos, getCellType({\n        node: cellNode,\n        row: rect.top,\n        col: rect.left\n      }), attrs[0]);\n      if (sel instanceof CellSelection) tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos), lastCell ? tr.doc.resolve(lastCell) : void 0));\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction setCellAttr(name, value) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value) return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection) state.selection.forEachCell((node, pos) => {\n        if (node.attrs[name] !== value) tr.setNodeMarkup(pos, null, {\n          ...node.attrs,\n          [name]: value\n        });\n      });else tr.setNodeMarkup($cell.pos, null, {\n        ...$cell.nodeAfter.attrs,\n        [name]: value\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction deprecated_toggleHeader(type) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state),\n        tr = state.tr;\n      const cells = rect.map.cellsInRect(type == \"column\" ? {\n        left: rect.left,\n        top: 0,\n        right: rect.right,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: 0,\n        top: rect.top,\n        right: rect.map.width,\n        bottom: rect.bottom\n      } : rect);\n      const nodes = cells.map(pos => rect.table.nodeAt(pos));\n      for (let i = 0; i < cells.length; i++) if (nodes[i].type == types.header_cell) tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs);\n      if (tr.steps.length == 0) for (let i = 0; i < cells.length; i++) tr.setNodeMarkup(rect.tableStart + cells[i], types.header_cell, nodes[i].attrs);\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toggleHeader(type, options) {\n  options = options || {\n    useDeprecatedLogic: false\n  };\n  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state),\n        tr = state.tr;\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\"column\", rect, types);\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      const cellsRect = type == \"column\" ? {\n        left: 0,\n        top: selectionStartsAt,\n        right: 1,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: selectionStartsAt,\n        top: 0,\n        right: rect.map.width,\n        bottom: 1\n      } : rect;\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach(relativeCellPos => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before) return $cell.pos - before.nodeSize;\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount) return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\nfunction goToNextCell(direction) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(state.tr.setSelection(TextSelection3.between($cell, moveCellForward($cell))).scrollIntoView());\n    }\n    return true;\n  };\n}\nfunction deleteTable(state, dispatch) {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch) dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView());\n      return true;\n    }\n  }\n  return false;\n}\n\n// src/index.ts\nfunction tableEditing() {\n  let {\n    allowTableNodeSelection = false\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new Plugin2({\n    key: tableEditingKey,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null) return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged) return cur;\n        const {\n          deleted,\n          pos\n        } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n      },\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection);\n    }\n  });\n}\nexport { CellBookmark, CellSelection, ResizeState, TableMap, TableView, clipCells as __clipCells, insertCells as __insertCells, pastedCells as __pastedCells, addColSpan, addColumn, addColumnAfter, addColumnBefore, addRow, addRowAfter, addRowBefore, cellAround, colCount, columnIsHeader, columnResizing, columnResizingPluginKey, deleteColumn, deleteRow, deleteTable, findCell, fixTables, fixTablesKey, goToNextCell, handlePaste, inSameTable, isInTable, mergeCells, moveCellForward, nextCell, pointsAtCell, removeColSpan, removeColumn, removeRow, rowIsHeader, selectedRect, selectionCell, setCellAttr, splitCell, splitCellWithType, tableEditing, tableEditingKey, tableNodeTypes, tableNodes, toggleHeader, toggleHeaderCell, toggleHeaderColumn, toggleHeaderRow, updateColumnsOnResize };","map":{"version":3,"names":["Plugin","Plugin2","Fragment","Slice","NodeSelection","NodeSelection2","Selection","SelectionRange","TextSelection","Decoration","DecorationSet","readFromCache","addToCache","WeakMap","cache","key","get","value","set","cacheSize","cachePos","i","length","TableMap","constructor","width","height","map","problems","findCell","pos","curPos","left","top","right","bottom","j","RangeError","colCount","nextCell","axis","dir","rectBetween","a","b","leftA","rightA","topA","bottomA","leftB","rightB","topB","bottomB","Math","min","max","cellsInRect","rect","result","seen","row","col","index","push","positionAt","table","rowStart","rowEnd","child","nodeSize","rowEndIndex","computeMap","type","spec","tableRole","name","findWidth","childCount","mapPos","colWidths","e","rowNode","cellNode","colspan","rowspan","colwidth","attrs","h","n","start","w","colW","widthIndex","prev","expectedPos","missing","tableMap","badWidths","findBadColWidths","hasRowSpan","rowWidth","prevRow","cell","node","nodeAt","updated","colWidth","freshColWidth","unshift","slice","PluginKey","getCellAttrs","dom","extraAttrs","widthAttr","getAttribute","widths","test","split","s","Number","prop","getter","getFromDOM","setCellAttrs","join","setter","setDOMAttr","tableNodes","options","cellAttributes","cellAttrs","default","content","isolating","group","tableGroup","parseDOM","tag","toDOM","table_row","table_cell","cellContent","getAttrs","table_header","tableNodeTypes","schema","cached","nodes","role","tableEditingKey","cellAround","$pos","d","depth","resolve","before","cellWrapping","isInTable","state","$head","selection","selectionCell","sel","$anchorCell","$headCell","$anchor","$cell","cellNear","head","after","nodeAfter","firstChild","doc","nodeBefore","lastChild","pointsAtCell","parent","moveCellForward","inSameTable","$cellA","$cellB","end","tableStart","moved","removeColSpan","arguments","undefined","splice","some","addColSpan","columnIsHeader","headerCell","header_cell","CellSelection","cells","filter","p","ranges","from","size","$from","$to","mapping","tableChanged","isRowSelection","rowSelection","isColSelection","colSelection","between","rows","rowContent","cellRect","extraLeft","extraRight","createAndFill","JSON","stringify","create","copy","fragment","replace","tr","empty","mapFrom","steps","findFrom","to","setSelection","replaceWith","forEachCell","f","anchorTop","headTop","anchorBottom","headBottom","anchorRect","headRect","anchorLeft","headLeft","anchorRight","headRight","eq","other","toJSON","anchor","fromJSON","json","anchorCell","headCell","getBookmark","CellBookmark","prototype","visible","jsonID","near","drawCellSelection","class","isCellBoundarySelection","_ref","afterFrom","beforeTo","isTextSelectionAcrossCells","_ref2","fromCellBoundaryNode","toCellBoundaryNode","parentOffset","normalizeSelection","allowTableNodeSelection","normalize","lastCell","PluginKey2","fixTablesKey","changedDescendants","old","cur","offset","oldSize","curSize","outer","scan","sameMarkup","nodesBetween","fixTables","oldState","check","fixTable","descendants","tablePos","mustAdd","prob","setNodeMarkup","first","last","add","side","insert","setMeta","Fragment3","Slice3","Selection2","TextSelection2","keydownHandler","Fragment2","Slice2","Transform","pastedCells","openStart","openEnd","fitSlice","ensureRectangular","r","append","nodeType","clipCells","_ref3","newWidth","newHeight","added","newRows","frag","createChecked","source","growTable","types","emptyHead","start2","header","emptyRow","isolateHorizontal","found","cellTop","cellLeft","isolateVertical","updatePos","insertCells","dispatch","Error","recomp","maps","handleKeyDown","ArrowLeft","arrow","ArrowRight","ArrowUp","ArrowDown","shiftArrow","Backspace","deleteCellSelection","Delete","maybeSetSelection","scrollIntoView","view","atEndOfCell","$next","newSel","cellSel","baseContent","docChanged","handleTripleClick","handlePaste","_","handleMouseDown","startEvent","_a","ctrlKey","metaKey","startDOMCell","domInCell","target","shiftKey","setCellSelection","preventDefault","cellUnderMouse","$anchor2","event","starting","getState","stop","root","removeEventListener","move","_event","addEventListener","indexAfter","cellPos","dirStr","endOfTextblock","parentNode","nodeName","mousePos","posAtCoords","clientX","clientY","PluginKey3","Decoration2","DecorationSet2","TableView","cellMinWidth","document","createElement","className","appendChild","colgroup","updateColumnsOnResize","contentDOM","update","ignoreMutation","record","contains","overrideCol","overrideValue","totalWidth","fixedWidth","nextDOM","hasWidth","cssWidth","style","nextSibling","removeChild","minWidth","columnResizingPluginKey","columnResizing","handleWidth","View","lastColumnResizable","plugin","init","props","nodeViews","ResizeState","apply","attributes","pluginState","activeHandle","handleDOMEvents","mousemove","handleMouseMove","mouseleave","handleMouseLeave","mousedown","handleMouseDown2","decorations","handleDecorations","dragging","action","getMeta","setHandle","setDragging","handle","domCellAround","getBoundingClientRect","edgeCell","updateHandle","currentColWidth","startX","startWidth","finish","event2","window","pluginState2","updateColumnWidth","draggedWidth","which","dragged","displayColumnWidth","_ref4","domAtPos","childNodes","domWidth","offsetWidth","parts","classList","indexOf","mapIndex","zeroes","Array","fill","widget","Fragment4","TextSelection3","selectedRect","addColumn","_ref5","refColumn","addColumnBefore","addColumnAfter","removeColumn","_ref6","mapStart","delete","deleteColumn","rowIsHeader","addRow","_ref7","rowPos","refRow","addRowBefore","addRowAfter","removeRow","_ref8","nextRow","newPos","deleteRow","isEmpty","c","isTextblock","cellsOverlapRectangle","_ref9","indexTop","indexLeft","indexBottom","indexRight","mergeCells","mergedPos","mergedCell","mapped","splitCell","nodeTypes","splitCellWithType","_ref10","getCellType","baseAttrs","setCellAttr","deprecated_toggleHeader","isHeaderEnabledByType","cellPositions","toggleHeader","useDeprecatedLogic","isHeaderRowEnabled","isHeaderColumnEnabled","isHeaderEnabled","selectionStartsAt","cellsRect","newType","forEach","relativeCellPos","toggleHeaderRow","toggleHeaderColumn","toggleHeaderCell","findNextCell","goToNextCell","direction","deleteTable","tableEditing","deleted","mapResult","createSelectionBetween","appendTransaction","__clipCells","__insertCells","__pastedCells"],"sources":["/Users/xander/go/hexon/frontend/node_modules/prosemirror-tables/dist/index.js"],"sourcesContent":["// src/index.ts\nimport { Plugin as Plugin2 } from \"prosemirror-state\";\n\n// src/cellselection.ts\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport {\n  NodeSelection as NodeSelection2,\n  Selection,\n  SelectionRange,\n  TextSelection\n} from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n  let cache = /* @__PURE__ */ new WeakMap();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key)\n        return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize)\n      cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\nvar TableMap = class {\n  constructor(width, height, map, problems) {\n    this.width = width;\n    this.height = height;\n    this.map = map;\n    this.problems = problems;\n  }\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos)\n        continue;\n      const left = i % this.width;\n      const top = i / this.width | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\n        bottom++;\n      }\n      return { left, top, right, bottom };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    const { left, right, top, bottom } = this.findCell(pos);\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width)\n        return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height)\n        return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB)\n    };\n  }\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    const result = [];\n    const seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n        if (seen[pos])\n          continue;\n        seen[pos] = true;\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0; ; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        while (index < rowEndIndex && this.map[index] < rowStart)\n          index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n};\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\")\n    throw new RangeError(\"Not a table node: \" + table.type.name);\n  const width = findWidth(table), height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems = null;\n  const colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++)\n    map[i] = 0;\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0)\n        mapPos++;\n      if (i == rowNode.childCount)\n        break;\n      const cellNode = rowNode.child(i);\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0)\n            map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: \"collision\",\n              row,\n              pos,\n              n: colspan - w\n            });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos)\n      if (map[mapPos++] == 0)\n        missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: \"missing\", row, n: missing });\n    pos++;\n  }\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height)\n      badWidths = true;\n  if (badWidths)\n    findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\nfunction findWidth(table) {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        const prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          const cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row)\n            rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1)\n        hasRowSpan = true;\n    }\n    if (width == -1)\n      width = rowWidth;\n    else if (width != rowWidth)\n      width = Math.max(width, rowWidth);\n  }\n  return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems)\n    map.problems = [];\n  const seen = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos])\n      continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    let updated = null;\n    const attrs = node.attrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: \"colwidth mismatch\",\n        pos,\n        colwidth: updated\n      });\n  }\n}\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth)\n    return attrs.colwidth.slice();\n  const result = [];\n  for (let i = 0; i < attrs.colspan; i++)\n    result.push(0);\n  return result;\n}\n\n// src/util.ts\nimport { PluginKey } from \"prosemirror-state\";\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n  if (typeof dom === \"string\") {\n    return {};\n  }\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s) => Number(s)) : null;\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  const result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n  const attrs = {};\n  if (node.attrs.colspan != 1)\n    attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1)\n    attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter)\n      setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\nfunction tableNodes(options) {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs = {\n    colspan: { default: 1 },\n    rowspan: { default: 1 },\n    colwidth: { default: null }\n  };\n  for (const prop in extraAttrs)\n    cellAttrs[prop] = { default: extraAttrs[prop].default };\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: \"table\" }],\n      toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{ tag: \"tr\" }],\n      toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"td\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"th\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name], role = type.spec.tableRole;\n      if (role)\n        result[role] = type;\n    }\n  }\n  return result;\n}\n\n// src/util.ts\nvar tableEditingKey = new PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == \"row\")\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === \"header_cell\")\n      return $pos.node(d);\n  }\n  return null;\n}\nfunction isInTable(state) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == \"row\")\n      return true;\n  return false;\n}\nfunction selectionCell(state) {\n  const sel = state.selection;\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    const role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos);\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    const role = before.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan - n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0))\n      result.colwidth = null;\n  }\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan + n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++)\n      result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n\n// src/cellselection.ts\nvar CellSelection = class extends Selection {\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween(\n      $anchorCell.pos - tableStart,\n      $headCell.pos - tableStart\n    );\n    const doc = $anchorCell.node(0);\n    const cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map((pos) => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size)\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n  map(doc, mapping) {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return CellSelection.colSelection($anchorCell, $headCell);\n      else\n        return new CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const rect = map.rectBetween(\n      this.$anchorCell.pos - tableStart,\n      this.$headCell.pos - tableStart\n    );\n    const seen = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        const pos = map.map[index];\n        if (seen[pos])\n          continue;\n        seen[pos] = true;\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw RangeError(`No cell with offset ${pos} found`);\n        }\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(\n              attrs,\n              attrs.colspan - extraRight,\n              extraRight\n            );\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw RangeError(\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`\n              );\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs);\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n  replace(tr, content = Slice.empty) {\n    const mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? Slice.empty : content\n      );\n    }\n    const sel = Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1\n    );\n    if (sel)\n      tr.setSelection(sel);\n  }\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n  forEachCell(f) {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const cells = map.cellsInRect(\n      map.rectBetween(\n        this.$anchorCell.pos - tableStart,\n        this.$headCell.pos - tableStart\n      )\n    );\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\n    }\n  }\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0)\n      return false;\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n  }\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0)\n      return false;\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n  eq(other) {\n    return other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[anchorRect.top * map.width]\n        );\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (headRect.top + 1) - 1]\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1]\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n  toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n  static fromJSON(doc, json) {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n};\nCellSelection.prototype.visible = false;\nSelection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))\n      return new CellSelection($anchorCell, $headCell);\n    else\n      return Selection.near($headCell, 1);\n  }\n};\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection))\n    return null;\n  const cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      Decoration.node(pos, pos + node.nodeSize, { class: \"selectedCell\" })\n    );\n  });\n  return DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({ $from, $to }) {\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6)\n    return false;\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth))\n      break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d))\n      break;\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize;\n  let role;\n  if (sel instanceof NodeSelection2 && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize)\n    (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// src/fixtables.ts\nimport { PluginKey as PluginKey2 } from \"prosemirror-state\";\nvar fixTablesKey = new PluginKey2(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n  const oldSize = old.childCount, curSize = cur.childCount;\n  outer:\n    for (let i = 0, j = 0; i < curSize; i++) {\n      const child = cur.child(i);\n      for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n        if (old.child(scan) == child) {\n          j = scan + 1;\n          offset += child.nodeSize;\n          continue outer;\n        }\n      }\n      f(child, offset);\n      if (j < oldSize && old.child(j).sameMarkup(child))\n        changedDescendants(old.child(j), child, offset + 1, f);\n      else\n        child.nodesBetween(0, child.content.size, f, offset + 1);\n      offset += child.nodeSize;\n    }\n}\nfunction fixTables(state, oldState) {\n  let tr;\n  const check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\")\n      tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState)\n    state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n  const map = TableMap.get(table);\n  if (!map.problems)\n    return tr;\n  if (!tr)\n    tr = state.tr;\n  const mustAdd = [];\n  for (let i = 0; i < map.height; i++)\n    mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == \"collision\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      const attrs = cell.attrs;\n      for (let j = 0; j < attrs.rowspan; j++)\n        mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)\n      );\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n\n      });\n    } else if (prob.type == \"colwidth mismatch\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth\n      });\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null)\n        first = i;\n      last = i;\n    }\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role = \"cell\";\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n        if (node)\n          nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n\n// src/input.ts\nimport { Fragment as Fragment3, Slice as Slice3 } from \"prosemirror-model\";\nimport {\n  Selection as Selection2,\n  TextSelection as TextSelection2\n} from \"prosemirror-state\";\nimport { keydownHandler } from \"prosemirror-keymap\";\n\n// src/copypaste.ts\nimport { Fragment as Fragment2, Slice as Slice2 } from \"prosemirror-model\";\nimport { Transform } from \"prosemirror-transform\";\nfunction pastedCells(slice) {\n  if (!slice.size)\n    return null;\n  let { content, openStart, openEnd } = slice;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema, rows = [];\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new Slice2(cells, left, right)\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(\n      openStart || openEnd ? fitSlice(\n        tableNodeTypes(schema).row,\n        new Slice2(content, openStart, openEnd)\n      ).content : content\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n  const widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++)\n    width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length)\n      rows.push(Fragment2.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill();\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(Fragment2.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\nfunction fitSlice(nodeType, slice) {\n  const node = nodeType.createAndFill();\n  const tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\n  if (width != newWidth) {\n    const added = [];\n    const newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row], cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.createChecked(\n            removeColSpan(\n              cell.attrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth\n            ),\n            cell.content\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [], source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            {\n              ...cell.attrs,\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n            },\n            cell.content\n          );\n        cells.push(cell);\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n  return { width, height, rows };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells = [];\n      let add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill());\n      else\n        add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++)\n        cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n      cells.push(\n        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())\n      );\n    }\n    const emptyRow = types.row.create(null, Fragment2.from(cells)), rows = [];\n    for (let i = map.height; i < height; i++)\n      rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height)\n    return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col, pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop\n      });\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill({\n          ...cell.attrs,\n          rowspan: cellTop + cell.attrs.rowspan - top\n        })\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width)\n    return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left, pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft)\n        )\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(\n          removeColSpan(cell.attrs, 0, left - cellLeft)\n        )\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error(\"No table found\");\n  }\n  let map = TableMap.get(table);\n  const { top, left } = rect;\n  const right = left + cells.width, bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error(\"No table found\");\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new Slice2(cells.rows[row - top], 0, 0)\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))\n    )\n  );\n  dispatch(tr);\n}\n\n// src/input.ts\nvar handleKeyDown = keydownHandler({\n  ArrowLeft: arrow(\"horiz\", -1),\n  ArrowRight: arrow(\"horiz\", 1),\n  ArrowUp: arrow(\"vert\", -1),\n  ArrowDown: arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  Backspace: deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  Delete: deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection))\n    return false;\n  if (dispatch)\n    dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view)\n      return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(sel.$headCell, dir)\n      );\n    }\n    if (axis != \"horiz\" && !sel.empty)\n      return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null)\n      return false;\n    if (axis == \"horiz\") {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(state.doc.resolve(sel.head + dir), dir)\n      );\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next)\n        newSel = Selection2.near($next, 1);\n      else if (dir < 0)\n        newSel = Selection2.near(state.doc.resolve($cell.before(-1)), -1);\n      else\n        newSel = Selection2.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view)\n      return false;\n    const sel = state.selection;\n    let cellSel;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null)\n        return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head)\n      return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(cellSel.$anchorCell, $head)\n    );\n  };\n}\nfunction deleteCellSelection(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection))\n    return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new Slice3(baseContent, 0, 0)\n        );\n    });\n    if (tr.docChanged)\n      dispatch(tr);\n  }\n  return true;\n}\nfunction handleTripleClick(view, pos) {\n  const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n  if (!$cell)\n    return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state))\n    return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          Fragment3.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice)\n          )\n        ]\n      };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown(view, startEvent) {\n  var _a;\n  if (startEvent.ctrlKey || startEvent.metaKey)\n    return;\n  const startDOMCell = domInCell(view, startEvent.target);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    return;\n  }\n  function setCellSelection($anchor2, event) {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor2, $head)) {\n      if (starting)\n        $head = $anchor2;\n      else\n        return;\n    }\n    const selection = new CellSelection($anchor2, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting)\n        tr.setMeta(tableEditingKey, $anchor2.pos);\n      view.dispatch(tr);\n    }\n  }\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (tableEditingKey.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n  function move(_event) {\n    const event = _event;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor2;\n    if (anchor != null) {\n      $anchor2 = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      $anchor2 = cellUnderMouse(view, startEvent);\n      if (!$anchor2)\n        return stop();\n    }\n    if ($anchor2)\n      setCellSelection($anchor2, event);\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection2))\n    return null;\n  const { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount))\n      return null;\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      const cellPos = $head.before(d);\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n  return null;\n}\nfunction cellUnderMouse(view, event) {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos)\n    return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// src/columnresizing.ts\nimport { Plugin, PluginKey as PluginKey3 } from \"prosemirror-state\";\nimport {\n  Decoration as Decoration2,\n  DecorationSet as DecorationSet2\n} from \"prosemirror-view\";\n\n// src/tableview.ts\nvar TableView = class {\n  constructor(node, cellMinWidth) {\n    this.node = node;\n    this.cellMinWidth = cellMinWidth;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"tableWrapper\";\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n    updateColumnsOnResize(node, this.colgroup, this.table, cellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n  }\n  update(node) {\n    if (node.type != this.node.type)\n      return false;\n    this.node = node;\n    updateColumnsOnResize(node, this.colgroup, this.table, this.cellMinWidth);\n    return true;\n  }\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n};\nfunction updateColumnsOnResize(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  var _a;\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  if (!row)\n    return;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const { colspan, colwidth } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth)\n        fixedWidth = false;\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth)\n          nextDOM.style.width = cssWidth;\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\n// src/columnresizing.ts\nvar columnResizingPluginKey = new PluginKey3(\n  \"tableColumnResizing\"\n);\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  View = TableView,\n  lastColumnResizable = true\n} = {}) {\n  const plugin = new Plugin({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        plugin.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (node, view) => new View(node, cellMinWidth, view);\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1 ? { class: \"resize-cursor\" } : {};\n      },\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(\n            view,\n            event,\n            handleWidth,\n            cellMinWidth,\n            lastColumnResizable\n          );\n        },\n        mouseleave: (view) => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown2(view, event, cellMinWidth);\n        }\n      },\n      decorations: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\nvar ResizeState = class {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n  apply(tr) {\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null)\n      return new ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== void 0)\n      return new ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n};\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState)\n    return;\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target);\n    let cell = -1;\n    if (target) {\n      const { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, \"left\", handleWidth);\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, \"right\", handleWidth);\n    }\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n      updateHandle(view, cell);\n    }\n  }\n}\nfunction handleMouseLeave(view) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\n    return false;\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, {\n      setDragging: { startX: event.clientX, startWidth: width }\n    })\n  );\n  function finish(event2) {\n    window.removeEventListener(\"mouseup\", finish);\n    window.removeEventListener(\"mousemove\", move);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        draggedWidth(pluginState2.dragging, event2, cellMinWidth)\n      );\n      view.dispatch(\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })\n      );\n    }\n  }\n  function move(event2) {\n    if (!event2.which)\n      return finish(event2);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (!pluginState2)\n      return;\n    if (pluginState2.dragging) {\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n      displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);\n    }\n  }\n  window.addEventListener(\"mouseup\", finish);\n  window.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width)\n    return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth, parts = colspan;\n  if (colwidth) {\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  }\n  return domWidth / parts;\n}\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  return target;\n}\nfunction edgeCell(view, event, side, handleWidth) {\n  const offset = side == \"right\" ? -handleWidth : handleWidth;\n  const found = view.posAtCoords({\n    left: event.clientX + offset,\n    top: event.clientY\n  });\n  if (!found)\n    return -1;\n  const { pos } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell)\n    return -1;\n  if (side == \"right\")\n    return $cell.pos;\n  const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })\n  );\n}\nfunction updateColumnWidth(view, cell, width) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width])\n      continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos).attrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width)\n      continue;\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });\n  }\n  if (tr.docChanged)\n    view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), start = $cell.start(-1);\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n  if (!dom)\n    return;\n  updateColumnsOnResize(\n    table,\n    dom.firstChild,\n    dom,\n    cellMinWidth,\n    col,\n    width\n  );\n}\nfunction zeroes(n) {\n  return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet2.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width - 1;\n    if ((col == map.width || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      const dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      decorations.push(Decoration2.widget(pos, dom));\n    }\n  }\n  return DecorationSet2.create(state.doc, decorations);\n}\n\n// src/commands.ts\nimport { Fragment as Fragment4 } from \"prosemirror-model\";\nimport {\n  TextSelection as TextSelection3\n} from \"prosemirror-state\";\nfunction selectedRect(state) {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect = sel instanceof CellSelection ? map.rectBetween(\n    sel.$anchorCell.pos - tableStart,\n    sel.$headCell.pos - tableStart\n  ) : map.findCell($pos.pos - tableStart);\n  return { ...rect, tableStart, map, table };\n}\nfunction addColumn(tr, { map, tableStart, table }, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs, col - map.colCount(pos))\n      );\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\nfunction removeColumn(tr, { map, table, tableStart }, col) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos);\n    const attrs = cell.attrs;\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(attrs, col - map.colCount(pos))\n      );\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width)\n      return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left)\n        break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  var _a;\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell)\n      return false;\n  return true;\n}\nfunction addRow(tr, { map, tableStart, table }, row) {\n  var _a;\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++)\n    rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n      const node = type == null ? void 0 : type.createAndFill();\n      if (node)\n        cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\nfunction removeRow(tr, { map, table, tableStart }, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++)\n    rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n    if (row > 0 && pos == map.map[index - map.width]) {\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.width && pos == map.map[index + map.width]) {\n      const cell = table.nodeAt(pos);\n      const attrs = cell.attrs;\n      const copy = cell.type.create(\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\n        cell.content\n      );\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state), tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height)\n      return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top)\n        break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction isEmpty(cell) {\n  const c = cell.content;\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\nfunction mergeCells(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)\n    return false;\n  const rect = selectedRect(state), { map } = rect;\n  if (cellsOverlapRectangle(map, rect))\n    return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen = {};\n    let content = Fragment4.empty;\n    let mergedPos;\n    let mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell)\n          continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell))\n            content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(\n        mergedCell.attrs,\n        mergedCell.attrs.colspan,\n        rect.right - rect.left - mergedCell.attrs.colspan\n      ),\n      rowspan: rect.bottom - rect.top\n    });\n    if (content.size) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))\n    );\n    dispatch(tr);\n  }\n  return true;\n}\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    var _a;\n    const sel = state.selection;\n    let cellNode;\n    let cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode)\n        return false;\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos)\n        return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1)\n        baseAttrs = { ...baseAttrs, rowspan: 1 };\n      if (baseAttrs.colspan > 1)\n        baseAttrs = { ...baseAttrs, colspan: 1 };\n      const rect = selectedRect(state), tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth ? {\n            ...baseAttrs,\n            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n          } : baseAttrs\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top)\n          pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top)\n            continue;\n          tr.insert(\n            lastCell = tr.mapping.map(pos + rect.tableStart, 1),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0]\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell ? tr.doc.resolve(lastCell) : void 0\n          )\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value)\n      return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, {\n              ...node.attrs,\n              [name]: value\n            });\n        });\n      else\n        tr.setNodeMarkup($cell.pos, null, {\n          ...$cell.nodeAfter.attrs,\n          [name]: value\n        });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction deprecated_toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const cells = rect.map.cellsInRect(\n        type == \"column\" ? {\n          left: rect.left,\n          top: 0,\n          right: rect.right,\n          bottom: rect.map.height\n        } : type == \"row\" ? {\n          left: 0,\n          top: rect.top,\n          right: rect.map.width,\n          bottom: rect.bottom\n        } : rect\n      );\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos));\n      for (let i = 0; i < cells.length; i++)\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs\n          );\n      if (tr.steps.length == 0)\n        for (let i = 0; i < cells.length; i++)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false };\n  if (options.useDeprecatedLogic)\n    return deprecated_toggleHeader(type);\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\n        \"column\",\n        rect,\n        types\n      );\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      const cellsRect = type == \"column\" ? {\n        left: 0,\n        top: selectionStartsAt,\n        right: 1,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: selectionStartsAt,\n        top: 0,\n        right: rect.map.width,\n        bottom: 1\n      } : rect;\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before)\n      return $cell.pos - before.nodeSize;\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount)\n        return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\nfunction goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null)\n      return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr.setSelection(TextSelection3.between($cell, moveCellForward($cell))).scrollIntoView()\n      );\n    }\n    return true;\n  };\n}\nfunction deleteTable(state, dispatch) {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()\n        );\n      return true;\n    }\n  }\n  return false;\n}\n\n// src/index.ts\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new Plugin2({\n    key: tableEditingKey,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null)\n          return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged)\n          return cur;\n        const { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n      },\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection\n      );\n    }\n  });\n}\nexport {\n  CellBookmark,\n  CellSelection,\n  ResizeState,\n  TableMap,\n  TableView,\n  clipCells as __clipCells,\n  insertCells as __insertCells,\n  pastedCells as __pastedCells,\n  addColSpan,\n  addColumn,\n  addColumnAfter,\n  addColumnBefore,\n  addRow,\n  addRowAfter,\n  addRowBefore,\n  cellAround,\n  colCount,\n  columnIsHeader,\n  columnResizing,\n  columnResizingPluginKey,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  findCell,\n  fixTables,\n  fixTablesKey,\n  goToNextCell,\n  handlePaste,\n  inSameTable,\n  isInTable,\n  mergeCells,\n  moveCellForward,\n  nextCell,\n  pointsAtCell,\n  removeColSpan,\n  removeColumn,\n  removeRow,\n  rowIsHeader,\n  selectedRect,\n  selectionCell,\n  setCellAttr,\n  splitCell,\n  splitCellWithType,\n  tableEditing,\n  tableEditingKey,\n  tableNodeTypes,\n  tableNodes,\n  toggleHeader,\n  toggleHeaderCell,\n  toggleHeaderColumn,\n  toggleHeaderRow,\n  updateColumnsOnResize\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}