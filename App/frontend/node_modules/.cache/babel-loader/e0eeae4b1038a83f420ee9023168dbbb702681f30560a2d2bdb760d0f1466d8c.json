{"ast":null,"code":"/*!\n* tiptap-commands v1.17.0\n* (c) 2021 Ã¼berdosis GbR (limited liability)\n* @license MIT\n*/\n\nimport { setBlockType, lift, wrapIn } from 'prosemirror-commands';\nexport { autoJoin, baseKeymap, chainCommands, createParagraphNear, deleteSelection, exitCode, joinBackward, joinDown, joinForward, joinUp, lift, liftEmptyBlock, macBaseKeymap, newlineInCode, pcBaseKeymap, selectAll, selectNodeBackward, selectNodeForward, selectParentNode, setBlockType, splitBlock, splitBlockKeepMarks, toggleMark, wrapIn } from 'prosemirror-commands';\nimport { liftListItem, wrapInList } from 'prosemirror-schema-list';\nexport { addListNodes, liftListItem, sinkListItem, splitListItem, wrapInList } from 'prosemirror-schema-list';\nimport { InputRule } from 'prosemirror-inputrules';\nexport { textblockTypeInputRule, wrappingInputRule } from 'prosemirror-inputrules';\nimport { Plugin } from 'prosemirror-state';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { getMarkRange, nodeIsActive, findParentNode } from 'tiptap-utils';\nfunction insertText() {\n  let text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return (state, dispatch) => {\n    const {\n      $from\n    } = state.selection;\n    const {\n      pos\n    } = $from.pos;\n    dispatch(state.tr.insertText(text, pos));\n    return true;\n  };\n}\nfunction getMarksBetween(start, end, state) {\n  let marks = [];\n  state.doc.nodesBetween(start, end, (node, pos) => {\n    marks = [...marks, ...node.marks.map(mark => ({\n      start: pos,\n      end: pos + node.nodeSize,\n      mark\n    }))];\n  });\n  return marks;\n}\nfunction markInputRule(regexp, markType, getAttrs) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    const {\n      tr\n    } = state;\n    const m = match.length - 1;\n    let markEnd = end;\n    let markStart = start;\n    if (match[m]) {\n      const matchStart = start + match[0].indexOf(match[m - 1]);\n      const matchEnd = matchStart + match[m - 1].length - 1;\n      const textStart = matchStart + match[m - 1].lastIndexOf(match[m]);\n      const textEnd = textStart + match[m].length;\n      const excludedMarks = getMarksBetween(start, end, state).filter(item => {\n        const {\n          excluded\n        } = item.mark.type;\n        return excluded.find(type => type.name === markType.name);\n      }).filter(item => item.end > matchStart);\n      if (excludedMarks.length) {\n        return false;\n      }\n      if (textEnd < matchEnd) {\n        tr.delete(textEnd, matchEnd);\n      }\n      if (textStart > matchStart) {\n        tr.delete(matchStart, textStart);\n      }\n      markStart = matchStart;\n      markEnd = markStart + match[m].length;\n    }\n    tr.addMark(markStart, markEnd, markType.create(attrs));\n    tr.removeStoredMark(markType);\n    return tr;\n  });\n}\nfunction nodeInputRule(regexp, type, getAttrs) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    const {\n      tr\n    } = state;\n    if (match[0]) {\n      tr.replaceWith(start - 1, end, type.create(attrs));\n    }\n    return tr;\n  });\n}\nfunction pasteRule(regexp, type, getAttrs) {\n  const handler = fragment => {\n    const nodes = [];\n    fragment.forEach(child => {\n      if (child.isText) {\n        const {\n          text\n        } = child;\n        let pos = 0;\n        let match;\n        do {\n          match = regexp.exec(text);\n          if (match) {\n            const start = match.index;\n            const end = start + match[0].length;\n            const attrs = getAttrs instanceof Function ? getAttrs(match[0]) : getAttrs;\n            if (start > 0) {\n              nodes.push(child.cut(pos, start));\n            }\n            nodes.push(child.cut(start, end).mark(type.create(attrs).addToSet(child.marks)));\n            pos = end;\n          }\n        } while (match);\n        if (pos < text.length) {\n          nodes.push(child.cut(pos));\n        }\n      } else {\n        nodes.push(child.copy(handler(child.content)));\n      }\n    });\n    return Fragment.fromArray(nodes);\n  };\n  return new Plugin({\n    props: {\n      transformPasted: slice => new Slice(handler(slice.content), slice.openStart, slice.openEnd)\n    }\n  });\n}\nfunction markPasteRule(regexp, type, getAttrs) {\n  const handler = (fragment, parent) => {\n    const nodes = [];\n    fragment.forEach(child => {\n      if (child.isText) {\n        const {\n          text,\n          marks\n        } = child;\n        let pos = 0;\n        let match;\n        const isLink = !!marks.filter(x => x.type.name === 'link')[0]; // eslint-disable-next-line\n\n        while (!isLink && (match = regexp.exec(text)) !== null) {\n          if (parent && parent.type.allowsMarkType(type) && match[1]) {\n            const start = match.index;\n            const end = start + match[0].length;\n            const textStart = start + match[0].indexOf(match[1]);\n            const textEnd = textStart + match[1].length;\n            const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs; // adding text before markdown to nodes\n\n            if (start > 0) {\n              nodes.push(child.cut(pos, start));\n            } // adding the markdown part to nodes\n\n            nodes.push(child.cut(textStart, textEnd).mark(type.create(attrs).addToSet(child.marks)));\n            pos = end;\n          }\n        } // adding rest of text to nodes\n\n        if (pos < text.length) {\n          nodes.push(child.cut(pos));\n        }\n      } else {\n        nodes.push(child.copy(handler(child.content, child)));\n      }\n    });\n    return Fragment.fromArray(nodes);\n  };\n  return new Plugin({\n    props: {\n      transformPasted: slice => new Slice(handler(slice.content), slice.openStart, slice.openEnd)\n    }\n  });\n}\nfunction removeMark(type) {\n  return (state, dispatch) => {\n    const {\n      tr,\n      selection\n    } = state;\n    let {\n      from,\n      to\n    } = selection;\n    const {\n      $from,\n      empty\n    } = selection;\n    if (empty) {\n      const range = getMarkRange($from, type);\n      from = range.from;\n      to = range.to;\n    }\n    tr.removeMark(from, to, type);\n    return dispatch(tr);\n  };\n}\nfunction replaceText() {\n  let range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let type = arguments.length > 1 ? arguments[1] : undefined;\n  let attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let fragment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Fragment.empty;\n  return (state, dispatch) => {\n    const {\n      $from,\n      $to\n    } = state.selection;\n    const index = $from.index();\n    const from = range ? range.from : $from.pos;\n    const to = range ? range.to : $to.pos;\n    if (!$from.parent.canReplaceWith(index, index, type)) {\n      return false;\n    }\n    if (dispatch) {\n      dispatch(state.tr.replaceWith(from, to, type.create(attrs, fragment)));\n    }\n    return true;\n  };\n}\nfunction setInlineBlockType(type) {\n  let attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return (state, dispatch) => {\n    const {\n      $from\n    } = state.selection;\n    const index = $from.index();\n    if (!$from.parent.canReplaceWith(index, index, type)) {\n      return false;\n    }\n    if (dispatch) {\n      dispatch(state.tr.replaceSelectionWith(type.create(attrs)));\n    }\n    return true;\n  };\n}\n\n// see https://github.com/ProseMirror/prosemirror-transform/blob/main/src/structure.js\n// Since this piece of code was \"borrowed\" from prosemirror, ESLint rules are ignored.\n\n/* eslint-disable max-len, no-plusplus, no-undef, eqeqeq */\n\nfunction canSplit(doc, pos) {\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let typesAfter = arguments.length > 3 ? arguments[3] : undefined;\n  const $pos = doc.resolve(pos);\n  const base = $pos.depth - depth;\n  const innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;\n  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) return false;\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    const node = $pos.node(d);\n    const index = $pos.index(d);\n    if (node.type.spec.isolating) return false;\n    let rest = node.content.cutByIndex(index, node.childCount);\n    const after = typesAfter && typesAfter[i] || node;\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs));\n    /* Change starts from here */\n    // if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n    //   return false\n\n    if (!node.canReplace(index + 1, node.childCount)) return false;\n    /* Change ends here */\n  }\n\n  const index = $pos.indexAfter(base);\n  const baseType = typesAfter && typesAfter[0];\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n} // this is a copy of splitListItem\n// see https://github.com/ProseMirror/prosemirror-schema-list/blob/main/src/schema-list.js\n\nfunction splitToDefaultListItem(itemType) {\n  return function (state, dispatch) {\n    const {\n      $from,\n      $to,\n      node\n    } = state.selection;\n    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) return false;\n    const grandParent = $from.node(-1);\n    if (grandParent.type != itemType) return false;\n    if ($from.parent.content.size == 0) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth == 2 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) return false;\n      if (dispatch) {\n        let wrap = Fragment.empty;\n        const keepItem = $from.index(-1) > 0; // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n\n        for (let d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d--) wrap = Fragment.from($from.node(d).copy(wrap)); // Add a second list item with an empty default start node\n\n        wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n        const tr = state.tr.replace($from.before(keepItem ? null : -1), $from.after(-3), new Slice(wrap, keepItem ? 3 : 2, 2));\n        tr.setSelection(state.selection.constructor.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))));\n        dispatch(tr.scrollIntoView());\n      }\n      return true;\n    }\n    const nextType = $to.pos == $from.end() ? grandParent.contentMatchAt($from.indexAfter(-1)).defaultType : null;\n    const tr = state.tr.delete($from.pos, $to.pos);\n    /* Change starts from here */\n    // let types = nextType && [null, {type: nextType}]\n\n    let types = nextType && [{\n      type: itemType\n    }, {\n      type: nextType\n    }];\n    if (!types) types = [{\n      type: itemType\n    }, null];\n    /* Change ends here */\n\n    if (!canSplit(tr.doc, $from.pos, 2, types)) return false;\n    if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n    return true;\n  };\n}\n/* eslint-enable max-len, no-plusplus, no-undef, eqeqeq */\n\nfunction toggleBlockType(type, toggletype) {\n  let attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return (state, dispatch, view) => {\n    const isActive = nodeIsActive(state, type, attrs);\n    if (isActive) {\n      return setBlockType(toggletype)(state, dispatch, view);\n    }\n    return setBlockType(type, attrs)(state, dispatch, view);\n  };\n}\nfunction isList(node, schema) {\n  return node.type === schema.nodes.bullet_list || node.type === schema.nodes.ordered_list || node.type === schema.nodes.todo_list;\n}\nfunction toggleList(listType, itemType) {\n  return (state, dispatch, view) => {\n    const {\n      schema,\n      selection\n    } = state;\n    const {\n      $from,\n      $to\n    } = selection;\n    const range = $from.blockRange($to);\n    if (!range) {\n      return false;\n    }\n    const parentList = findParentNode(node => isList(node, schema))(selection);\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n      if (parentList.node.type === listType) {\n        return liftListItem(itemType)(state, dispatch, view);\n      }\n      if (isList(parentList.node, schema) && listType.validContent(parentList.node.content)) {\n        const {\n          tr\n        } = state;\n        tr.setNodeMarkup(parentList.pos, listType);\n        if (dispatch) {\n          dispatch(tr);\n        }\n        return false;\n      }\n    }\n    return wrapInList(listType)(state, dispatch, view);\n  };\n}\nfunction toggleWrap(type) {\n  let attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return (state, dispatch, view) => {\n    const isActive = nodeIsActive(state, type, attrs);\n    if (isActive) {\n      return lift(state, dispatch);\n    }\n    return wrapIn(type, attrs)(state, dispatch, view);\n  };\n}\nfunction updateMark(type, attrs) {\n  return (state, dispatch) => {\n    const {\n      tr,\n      selection,\n      doc\n    } = state;\n    const {\n      ranges,\n      empty\n    } = selection;\n    if (empty) {\n      const {\n        from,\n        to\n      } = getMarkRange(selection.$from, type);\n      if (doc.rangeHasMark(from, to, type)) {\n        tr.removeMark(from, to, type);\n      }\n      tr.addMark(from, to, type.create(attrs));\n    } else {\n      ranges.forEach(ref$1 => {\n        const {\n          $to,\n          $from\n        } = ref$1;\n        if (doc.rangeHasMark($from.pos, $to.pos, type)) {\n          tr.removeMark($from.pos, $to.pos, type);\n        }\n        tr.addMark($from.pos, $to.pos, type.create(attrs));\n      });\n    }\n    return dispatch(tr);\n  };\n}\nexport { insertText, markInputRule, markPasteRule, nodeInputRule, pasteRule, removeMark, replaceText, setInlineBlockType, splitToDefaultListItem, toggleBlockType, toggleList, toggleWrap, updateMark };","map":{"version":3,"names":["setBlockType","lift","wrapIn","autoJoin","baseKeymap","chainCommands","createParagraphNear","deleteSelection","exitCode","joinBackward","joinDown","joinForward","joinUp","liftEmptyBlock","macBaseKeymap","newlineInCode","pcBaseKeymap","selectAll","selectNodeBackward","selectNodeForward","selectParentNode","splitBlock","splitBlockKeepMarks","toggleMark","liftListItem","wrapInList","addListNodes","sinkListItem","splitListItem","InputRule","textblockTypeInputRule","wrappingInputRule","Plugin","Slice","Fragment","getMarkRange","nodeIsActive","findParentNode","insertText","text","arguments","length","undefined","state","dispatch","$from","selection","pos","tr","getMarksBetween","start","end","marks","doc","nodesBetween","node","map","mark","nodeSize","markInputRule","regexp","markType","getAttrs","match","attrs","Function","m","markEnd","markStart","matchStart","indexOf","matchEnd","textStart","lastIndexOf","textEnd","excludedMarks","filter","item","excluded","type","find","name","delete","addMark","create","removeStoredMark","nodeInputRule","replaceWith","pasteRule","handler","fragment","nodes","forEach","child","isText","exec","index","push","cut","addToSet","copy","content","fromArray","props","transformPasted","slice","openStart","openEnd","markPasteRule","parent","isLink","x","allowsMarkType","removeMark","from","to","empty","range","replaceText","$to","canReplaceWith","setInlineBlockType","replaceSelectionWith","canSplit","depth","typesAfter","$pos","resolve","base","innerType","spec","isolating","canReplace","childCount","validContent","cutByIndex","d","i","rest","after","replaceChild","indexAfter","baseType","splitToDefaultListItem","itemType","isBlock","sameParent","grandParent","size","wrap","keepItem","append","createAndFill","replace","before","setSelection","constructor","near","scrollIntoView","nextType","contentMatchAt","defaultType","types","split","toggleBlockType","toggletype","view","isActive","isList","schema","bullet_list","ordered_list","todo_list","toggleList","listType","blockRange","parentList","setNodeMarkup","toggleWrap","updateMark","ranges","rangeHasMark","ref$1"],"sources":["/Users/xander/go/hexon/frontend/node_modules/tiptap-commands/dist/commands.esm.js"],"sourcesContent":["\n    /*!\n    * tiptap-commands v1.17.0\n    * (c) 2021 Ã¼berdosis GbR (limited liability)\n    * @license MIT\n    */\n  \nimport { setBlockType, lift, wrapIn } from 'prosemirror-commands';\nexport { autoJoin, baseKeymap, chainCommands, createParagraphNear, deleteSelection, exitCode, joinBackward, joinDown, joinForward, joinUp, lift, liftEmptyBlock, macBaseKeymap, newlineInCode, pcBaseKeymap, selectAll, selectNodeBackward, selectNodeForward, selectParentNode, setBlockType, splitBlock, splitBlockKeepMarks, toggleMark, wrapIn } from 'prosemirror-commands';\nimport { liftListItem, wrapInList } from 'prosemirror-schema-list';\nexport { addListNodes, liftListItem, sinkListItem, splitListItem, wrapInList } from 'prosemirror-schema-list';\nimport { InputRule } from 'prosemirror-inputrules';\nexport { textblockTypeInputRule, wrappingInputRule } from 'prosemirror-inputrules';\nimport { Plugin } from 'prosemirror-state';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { getMarkRange, nodeIsActive, findParentNode } from 'tiptap-utils';\n\nfunction insertText (text = '') {\n  return (state, dispatch) => {\n    const {\n      $from\n    } = state.selection;\n    const {\n      pos\n    } = $from.pos;\n    dispatch(state.tr.insertText(text, pos));\n    return true;\n  };\n}\n\nfunction getMarksBetween(start, end, state) {\n  let marks = [];\n  state.doc.nodesBetween(start, end, (node, pos) => {\n    marks = [...marks, ...node.marks.map(mark => ({\n      start: pos,\n      end: pos + node.nodeSize,\n      mark\n    }))];\n  });\n  return marks;\n}\n\nfunction markInputRule (regexp, markType, getAttrs) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    const {\n      tr\n    } = state;\n    const m = match.length - 1;\n    let markEnd = end;\n    let markStart = start;\n\n    if (match[m]) {\n      const matchStart = start + match[0].indexOf(match[m - 1]);\n      const matchEnd = matchStart + match[m - 1].length - 1;\n      const textStart = matchStart + match[m - 1].lastIndexOf(match[m]);\n      const textEnd = textStart + match[m].length;\n      const excludedMarks = getMarksBetween(start, end, state).filter(item => {\n        const {\n          excluded\n        } = item.mark.type;\n        return excluded.find(type => type.name === markType.name);\n      }).filter(item => item.end > matchStart);\n\n      if (excludedMarks.length) {\n        return false;\n      }\n\n      if (textEnd < matchEnd) {\n        tr.delete(textEnd, matchEnd);\n      }\n\n      if (textStart > matchStart) {\n        tr.delete(matchStart, textStart);\n      }\n\n      markStart = matchStart;\n      markEnd = markStart + match[m].length;\n    }\n\n    tr.addMark(markStart, markEnd, markType.create(attrs));\n    tr.removeStoredMark(markType);\n    return tr;\n  });\n}\n\nfunction nodeInputRule (regexp, type, getAttrs) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    const {\n      tr\n    } = state;\n\n    if (match[0]) {\n      tr.replaceWith(start - 1, end, type.create(attrs));\n    }\n\n    return tr;\n  });\n}\n\nfunction pasteRule (regexp, type, getAttrs) {\n  const handler = fragment => {\n    const nodes = [];\n    fragment.forEach(child => {\n      if (child.isText) {\n        const {\n          text\n        } = child;\n        let pos = 0;\n        let match;\n\n        do {\n          match = regexp.exec(text);\n\n          if (match) {\n            const start = match.index;\n            const end = start + match[0].length;\n            const attrs = getAttrs instanceof Function ? getAttrs(match[0]) : getAttrs;\n\n            if (start > 0) {\n              nodes.push(child.cut(pos, start));\n            }\n\n            nodes.push(child.cut(start, end).mark(type.create(attrs).addToSet(child.marks)));\n            pos = end;\n          }\n        } while (match);\n\n        if (pos < text.length) {\n          nodes.push(child.cut(pos));\n        }\n      } else {\n        nodes.push(child.copy(handler(child.content)));\n      }\n    });\n    return Fragment.fromArray(nodes);\n  };\n\n  return new Plugin({\n    props: {\n      transformPasted: slice => new Slice(handler(slice.content), slice.openStart, slice.openEnd)\n    }\n  });\n}\n\nfunction markPasteRule (regexp, type, getAttrs) {\n  const handler = (fragment, parent) => {\n    const nodes = [];\n    fragment.forEach(child => {\n      if (child.isText) {\n        const {\n          text,\n          marks\n        } = child;\n        let pos = 0;\n        let match;\n        const isLink = !!marks.filter(x => x.type.name === 'link')[0]; // eslint-disable-next-line\n\n        while (!isLink && (match = regexp.exec(text)) !== null) {\n          if (parent && parent.type.allowsMarkType(type) && match[1]) {\n            const start = match.index;\n            const end = start + match[0].length;\n            const textStart = start + match[0].indexOf(match[1]);\n            const textEnd = textStart + match[1].length;\n            const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs; // adding text before markdown to nodes\n\n            if (start > 0) {\n              nodes.push(child.cut(pos, start));\n            } // adding the markdown part to nodes\n\n\n            nodes.push(child.cut(textStart, textEnd).mark(type.create(attrs).addToSet(child.marks)));\n            pos = end;\n          }\n        } // adding rest of text to nodes\n\n\n        if (pos < text.length) {\n          nodes.push(child.cut(pos));\n        }\n      } else {\n        nodes.push(child.copy(handler(child.content, child)));\n      }\n    });\n    return Fragment.fromArray(nodes);\n  };\n\n  return new Plugin({\n    props: {\n      transformPasted: slice => new Slice(handler(slice.content), slice.openStart, slice.openEnd)\n    }\n  });\n}\n\nfunction removeMark (type) {\n  return (state, dispatch) => {\n    const {\n      tr,\n      selection\n    } = state;\n    let {\n      from,\n      to\n    } = selection;\n    const {\n      $from,\n      empty\n    } = selection;\n\n    if (empty) {\n      const range = getMarkRange($from, type);\n      from = range.from;\n      to = range.to;\n    }\n\n    tr.removeMark(from, to, type);\n    return dispatch(tr);\n  };\n}\n\nfunction replaceText (range = null, type, attrs = {}, fragment = Fragment.empty) {\n  return (state, dispatch) => {\n    const {\n      $from,\n      $to\n    } = state.selection;\n    const index = $from.index();\n    const from = range ? range.from : $from.pos;\n    const to = range ? range.to : $to.pos;\n\n    if (!$from.parent.canReplaceWith(index, index, type)) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.replaceWith(from, to, type.create(attrs, fragment)));\n    }\n\n    return true;\n  };\n}\n\nfunction setInlineBlockType (type, attrs = {}) {\n  return (state, dispatch) => {\n    const {\n      $from\n    } = state.selection;\n    const index = $from.index();\n\n    if (!$from.parent.canReplaceWith(index, index, type)) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.replaceSelectionWith(type.create(attrs)));\n    }\n\n    return true;\n  };\n}\n\n// see https://github.com/ProseMirror/prosemirror-transform/blob/main/src/structure.js\n// Since this piece of code was \"borrowed\" from prosemirror, ESLint rules are ignored.\n\n/* eslint-disable max-len, no-plusplus, no-undef, eqeqeq */\n\nfunction canSplit(doc, pos, depth = 1, typesAfter) {\n  const $pos = doc.resolve(pos);\n  const base = $pos.depth - depth;\n  const innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;\n  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) return false;\n\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    const node = $pos.node(d);\n    const index = $pos.index(d);\n    if (node.type.spec.isolating) return false;\n    let rest = node.content.cutByIndex(index, node.childCount);\n    const after = typesAfter && typesAfter[i] || node;\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs));\n    /* Change starts from here */\n    // if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n    //   return false\n\n    if (!node.canReplace(index + 1, node.childCount)) return false;\n    /* Change ends here */\n  }\n\n  const index = $pos.indexAfter(base);\n  const baseType = typesAfter && typesAfter[0];\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n} // this is a copy of splitListItem\n// see https://github.com/ProseMirror/prosemirror-schema-list/blob/main/src/schema-list.js\n\n\nfunction splitToDefaultListItem(itemType) {\n  return function (state, dispatch) {\n    const {\n      $from,\n      $to,\n      node\n    } = state.selection;\n    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) return false;\n    const grandParent = $from.node(-1);\n    if (grandParent.type != itemType) return false;\n\n    if ($from.parent.content.size == 0) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth == 2 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) return false;\n\n      if (dispatch) {\n        let wrap = Fragment.empty;\n        const keepItem = $from.index(-1) > 0; // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n\n        for (let d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d--) wrap = Fragment.from($from.node(d).copy(wrap)); // Add a second list item with an empty default start node\n\n\n        wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n        const tr = state.tr.replace($from.before(keepItem ? null : -1), $from.after(-3), new Slice(wrap, keepItem ? 3 : 2, 2));\n        tr.setSelection(state.selection.constructor.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))));\n        dispatch(tr.scrollIntoView());\n      }\n\n      return true;\n    }\n\n    const nextType = $to.pos == $from.end() ? grandParent.contentMatchAt($from.indexAfter(-1)).defaultType : null;\n    const tr = state.tr.delete($from.pos, $to.pos);\n    /* Change starts from here */\n    // let types = nextType && [null, {type: nextType}]\n\n    let types = nextType && [{\n      type: itemType\n    }, {\n      type: nextType\n    }];\n    if (!types) types = [{\n      type: itemType\n    }, null];\n    /* Change ends here */\n\n    if (!canSplit(tr.doc, $from.pos, 2, types)) return false;\n    if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n    return true;\n  };\n}\n/* eslint-enable max-len, no-plusplus, no-undef, eqeqeq */\n\nfunction toggleBlockType (type, toggletype, attrs = {}) {\n  return (state, dispatch, view) => {\n    const isActive = nodeIsActive(state, type, attrs);\n\n    if (isActive) {\n      return setBlockType(toggletype)(state, dispatch, view);\n    }\n\n    return setBlockType(type, attrs)(state, dispatch, view);\n  };\n}\n\nfunction isList(node, schema) {\n  return node.type === schema.nodes.bullet_list || node.type === schema.nodes.ordered_list || node.type === schema.nodes.todo_list;\n}\n\nfunction toggleList(listType, itemType) {\n  return (state, dispatch, view) => {\n    const {\n      schema,\n      selection\n    } = state;\n    const {\n      $from,\n      $to\n    } = selection;\n    const range = $from.blockRange($to);\n\n    if (!range) {\n      return false;\n    }\n\n    const parentList = findParentNode(node => isList(node, schema))(selection);\n\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n      if (parentList.node.type === listType) {\n        return liftListItem(itemType)(state, dispatch, view);\n      }\n\n      if (isList(parentList.node, schema) && listType.validContent(parentList.node.content)) {\n        const {\n          tr\n        } = state;\n        tr.setNodeMarkup(parentList.pos, listType);\n\n        if (dispatch) {\n          dispatch(tr);\n        }\n\n        return false;\n      }\n    }\n\n    return wrapInList(listType)(state, dispatch, view);\n  };\n}\n\nfunction toggleWrap (type, attrs = {}) {\n  return (state, dispatch, view) => {\n    const isActive = nodeIsActive(state, type, attrs);\n\n    if (isActive) {\n      return lift(state, dispatch);\n    }\n\n    return wrapIn(type, attrs)(state, dispatch, view);\n  };\n}\n\nfunction updateMark (type, attrs) {\n  return (state, dispatch) => {\n    const {\n      tr,\n      selection,\n      doc\n    } = state;\n    const {\n      ranges,\n      empty\n    } = selection;\n\n    if (empty) {\n      const {\n        from,\n        to\n      } = getMarkRange(selection.$from, type);\n\n      if (doc.rangeHasMark(from, to, type)) {\n        tr.removeMark(from, to, type);\n      }\n\n      tr.addMark(from, to, type.create(attrs));\n    } else {\n      ranges.forEach(ref$1 => {\n        const {\n          $to,\n          $from\n        } = ref$1;\n\n        if (doc.rangeHasMark($from.pos, $to.pos, type)) {\n          tr.removeMark($from.pos, $to.pos, type);\n        }\n\n        tr.addMark($from.pos, $to.pos, type.create(attrs));\n      });\n    }\n\n    return dispatch(tr);\n  };\n}\n\nexport { insertText, markInputRule, markPasteRule, nodeInputRule, pasteRule, removeMark, replaceText, setInlineBlockType, splitToDefaultListItem, toggleBlockType, toggleList, toggleWrap, updateMark };\n"],"mappings":"AACI;AACJ;AACA;AACA;AACA;;AAEA,SAASA,YAAY,EAAEC,IAAI,EAAEC,MAAM,QAAQ,sBAAsB;AACjE,SAASC,QAAQ,EAAEC,UAAU,EAAEC,aAAa,EAAEC,mBAAmB,EAAEC,eAAe,EAAEC,QAAQ,EAAEC,YAAY,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,MAAM,EAAEX,IAAI,EAAEY,cAAc,EAAEC,aAAa,EAAEC,aAAa,EAAEC,YAAY,EAAEC,SAAS,EAAEC,kBAAkB,EAAEC,iBAAiB,EAAEC,gBAAgB,EAAEpB,YAAY,EAAEqB,UAAU,EAAEC,mBAAmB,EAAEC,UAAU,EAAErB,MAAM,QAAQ,sBAAsB;AAChX,SAASsB,YAAY,EAAEC,UAAU,QAAQ,yBAAyB;AAClE,SAASC,YAAY,EAAEF,YAAY,EAAEG,YAAY,EAAEC,aAAa,EAAEH,UAAU,QAAQ,yBAAyB;AAC7G,SAASI,SAAS,QAAQ,wBAAwB;AAClD,SAASC,sBAAsB,EAAEC,iBAAiB,QAAQ,wBAAwB;AAClF,SAASC,MAAM,QAAQ,mBAAmB;AAC1C,SAASC,KAAK,EAAEC,QAAQ,QAAQ,mBAAmB;AACnD,SAASC,YAAY,EAAEC,YAAY,EAAEC,cAAc,QAAQ,cAAc;AAEzE,SAASC,UAAUA,CAAA,EAAa;EAAA,IAAXC,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;EAC5B,OAAO,CAACG,KAAK,EAAEC,QAAQ,KAAK;IAC1B,MAAM;MACJC;IACF,CAAC,GAAGF,KAAK,CAACG,SAAS;IACnB,MAAM;MACJC;IACF,CAAC,GAAGF,KAAK,CAACE,GAAG;IACbH,QAAQ,CAACD,KAAK,CAACK,EAAE,CAACV,UAAU,CAACC,IAAI,EAAEQ,GAAG,CAAC,CAAC;IACxC,OAAO,IAAI;EACb,CAAC;AACH;AAEA,SAASE,eAAeA,CAACC,KAAK,EAAEC,GAAG,EAAER,KAAK,EAAE;EAC1C,IAAIS,KAAK,GAAG,EAAE;EACdT,KAAK,CAACU,GAAG,CAACC,YAAY,CAACJ,KAAK,EAAEC,GAAG,EAAE,CAACI,IAAI,EAAER,GAAG,KAAK;IAChDK,KAAK,GAAG,CAAC,GAAGA,KAAK,EAAE,GAAGG,IAAI,CAACH,KAAK,CAACI,GAAG,CAACC,IAAI,KAAK;MAC5CP,KAAK,EAAEH,GAAG;MACVI,GAAG,EAAEJ,GAAG,GAAGQ,IAAI,CAACG,QAAQ;MACxBD;IACF,CAAC,CAAC,CAAC,CAAC;EACN,CAAC,CAAC;EACF,OAAOL,KAAK;AACd;AAEA,SAASO,aAAaA,CAAEC,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,EAAE;EAClD,OAAO,IAAIjC,SAAS,CAAC+B,MAAM,EAAE,CAACjB,KAAK,EAAEoB,KAAK,EAAEb,KAAK,EAAEC,GAAG,KAAK;IACzD,MAAMa,KAAK,GAAGF,QAAQ,YAAYG,QAAQ,GAAGH,QAAQ,CAACC,KAAK,CAAC,GAAGD,QAAQ;IACvE,MAAM;MACJd;IACF,CAAC,GAAGL,KAAK;IACT,MAAMuB,CAAC,GAAGH,KAAK,CAACtB,MAAM,GAAG,CAAC;IAC1B,IAAI0B,OAAO,GAAGhB,GAAG;IACjB,IAAIiB,SAAS,GAAGlB,KAAK;IAErB,IAAIa,KAAK,CAACG,CAAC,CAAC,EAAE;MACZ,MAAMG,UAAU,GAAGnB,KAAK,GAAGa,KAAK,CAAC,CAAC,CAAC,CAACO,OAAO,CAACP,KAAK,CAACG,CAAC,GAAG,CAAC,CAAC,CAAC;MACzD,MAAMK,QAAQ,GAAGF,UAAU,GAAGN,KAAK,CAACG,CAAC,GAAG,CAAC,CAAC,CAACzB,MAAM,GAAG,CAAC;MACrD,MAAM+B,SAAS,GAAGH,UAAU,GAAGN,KAAK,CAACG,CAAC,GAAG,CAAC,CAAC,CAACO,WAAW,CAACV,KAAK,CAACG,CAAC,CAAC,CAAC;MACjE,MAAMQ,OAAO,GAAGF,SAAS,GAAGT,KAAK,CAACG,CAAC,CAAC,CAACzB,MAAM;MAC3C,MAAMkC,aAAa,GAAG1B,eAAe,CAACC,KAAK,EAAEC,GAAG,EAAER,KAAK,CAAC,CAACiC,MAAM,CAACC,IAAI,IAAI;QACtE,MAAM;UACJC;QACF,CAAC,GAAGD,IAAI,CAACpB,IAAI,CAACsB,IAAI;QAClB,OAAOD,QAAQ,CAACE,IAAI,CAACD,IAAI,IAAIA,IAAI,CAACE,IAAI,KAAKpB,QAAQ,CAACoB,IAAI,CAAC;MAC3D,CAAC,CAAC,CAACL,MAAM,CAACC,IAAI,IAAIA,IAAI,CAAC1B,GAAG,GAAGkB,UAAU,CAAC;MAExC,IAAIM,aAAa,CAAClC,MAAM,EAAE;QACxB,OAAO,KAAK;MACd;MAEA,IAAIiC,OAAO,GAAGH,QAAQ,EAAE;QACtBvB,EAAE,CAACkC,MAAM,CAACR,OAAO,EAAEH,QAAQ,CAAC;MAC9B;MAEA,IAAIC,SAAS,GAAGH,UAAU,EAAE;QAC1BrB,EAAE,CAACkC,MAAM,CAACb,UAAU,EAAEG,SAAS,CAAC;MAClC;MAEAJ,SAAS,GAAGC,UAAU;MACtBF,OAAO,GAAGC,SAAS,GAAGL,KAAK,CAACG,CAAC,CAAC,CAACzB,MAAM;IACvC;IAEAO,EAAE,CAACmC,OAAO,CAACf,SAAS,EAAED,OAAO,EAAEN,QAAQ,CAACuB,MAAM,CAACpB,KAAK,CAAC,CAAC;IACtDhB,EAAE,CAACqC,gBAAgB,CAACxB,QAAQ,CAAC;IAC7B,OAAOb,EAAE;EACX,CAAC,CAAC;AACJ;AAEA,SAASsC,aAAaA,CAAE1B,MAAM,EAAEmB,IAAI,EAAEjB,QAAQ,EAAE;EAC9C,OAAO,IAAIjC,SAAS,CAAC+B,MAAM,EAAE,CAACjB,KAAK,EAAEoB,KAAK,EAAEb,KAAK,EAAEC,GAAG,KAAK;IACzD,MAAMa,KAAK,GAAGF,QAAQ,YAAYG,QAAQ,GAAGH,QAAQ,CAACC,KAAK,CAAC,GAAGD,QAAQ;IACvE,MAAM;MACJd;IACF,CAAC,GAAGL,KAAK;IAET,IAAIoB,KAAK,CAAC,CAAC,CAAC,EAAE;MACZf,EAAE,CAACuC,WAAW,CAACrC,KAAK,GAAG,CAAC,EAAEC,GAAG,EAAE4B,IAAI,CAACK,MAAM,CAACpB,KAAK,CAAC,CAAC;IACpD;IAEA,OAAOhB,EAAE;EACX,CAAC,CAAC;AACJ;AAEA,SAASwC,SAASA,CAAE5B,MAAM,EAAEmB,IAAI,EAAEjB,QAAQ,EAAE;EAC1C,MAAM2B,OAAO,GAAGC,QAAQ,IAAI;IAC1B,MAAMC,KAAK,GAAG,EAAE;IAChBD,QAAQ,CAACE,OAAO,CAACC,KAAK,IAAI;MACxB,IAAIA,KAAK,CAACC,MAAM,EAAE;QAChB,MAAM;UACJvD;QACF,CAAC,GAAGsD,KAAK;QACT,IAAI9C,GAAG,GAAG,CAAC;QACX,IAAIgB,KAAK;QAET,GAAG;UACDA,KAAK,GAAGH,MAAM,CAACmC,IAAI,CAACxD,IAAI,CAAC;UAEzB,IAAIwB,KAAK,EAAE;YACT,MAAMb,KAAK,GAAGa,KAAK,CAACiC,KAAK;YACzB,MAAM7C,GAAG,GAAGD,KAAK,GAAGa,KAAK,CAAC,CAAC,CAAC,CAACtB,MAAM;YACnC,MAAMuB,KAAK,GAAGF,QAAQ,YAAYG,QAAQ,GAAGH,QAAQ,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGD,QAAQ;YAE1E,IAAIZ,KAAK,GAAG,CAAC,EAAE;cACbyC,KAAK,CAACM,IAAI,CAACJ,KAAK,CAACK,GAAG,CAACnD,GAAG,EAAEG,KAAK,CAAC,CAAC;YACnC;YAEAyC,KAAK,CAACM,IAAI,CAACJ,KAAK,CAACK,GAAG,CAAChD,KAAK,EAAEC,GAAG,CAAC,CAACM,IAAI,CAACsB,IAAI,CAACK,MAAM,CAACpB,KAAK,CAAC,CAACmC,QAAQ,CAACN,KAAK,CAACzC,KAAK,CAAC,CAAC,CAAC;YAChFL,GAAG,GAAGI,GAAG;UACX;QACF,CAAC,QAAQY,KAAK;QAEd,IAAIhB,GAAG,GAAGR,IAAI,CAACE,MAAM,EAAE;UACrBkD,KAAK,CAACM,IAAI,CAACJ,KAAK,CAACK,GAAG,CAACnD,GAAG,CAAC,CAAC;QAC5B;MACF,CAAC,MAAM;QACL4C,KAAK,CAACM,IAAI,CAACJ,KAAK,CAACO,IAAI,CAACX,OAAO,CAACI,KAAK,CAACQ,OAAO,CAAC,CAAC,CAAC;MAChD;IACF,CAAC,CAAC;IACF,OAAOnE,QAAQ,CAACoE,SAAS,CAACX,KAAK,CAAC;EAClC,CAAC;EAED,OAAO,IAAI3D,MAAM,CAAC;IAChBuE,KAAK,EAAE;MACLC,eAAe,EAAEC,KAAK,IAAI,IAAIxE,KAAK,CAACwD,OAAO,CAACgB,KAAK,CAACJ,OAAO,CAAC,EAAEI,KAAK,CAACC,SAAS,EAAED,KAAK,CAACE,OAAO;IAC5F;EACF,CAAC,CAAC;AACJ;AAEA,SAASC,aAAaA,CAAEhD,MAAM,EAAEmB,IAAI,EAAEjB,QAAQ,EAAE;EAC9C,MAAM2B,OAAO,GAAGA,CAACC,QAAQ,EAAEmB,MAAM,KAAK;IACpC,MAAMlB,KAAK,GAAG,EAAE;IAChBD,QAAQ,CAACE,OAAO,CAACC,KAAK,IAAI;MACxB,IAAIA,KAAK,CAACC,MAAM,EAAE;QAChB,MAAM;UACJvD,IAAI;UACJa;QACF,CAAC,GAAGyC,KAAK;QACT,IAAI9C,GAAG,GAAG,CAAC;QACX,IAAIgB,KAAK;QACT,MAAM+C,MAAM,GAAG,CAAC,CAAC1D,KAAK,CAACwB,MAAM,CAACmC,CAAC,IAAIA,CAAC,CAAChC,IAAI,CAACE,IAAI,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;QAE/D,OAAO,CAAC6B,MAAM,IAAI,CAAC/C,KAAK,GAAGH,MAAM,CAACmC,IAAI,CAACxD,IAAI,CAAC,MAAM,IAAI,EAAE;UACtD,IAAIsE,MAAM,IAAIA,MAAM,CAAC9B,IAAI,CAACiC,cAAc,CAACjC,IAAI,CAAC,IAAIhB,KAAK,CAAC,CAAC,CAAC,EAAE;YAC1D,MAAMb,KAAK,GAAGa,KAAK,CAACiC,KAAK;YACzB,MAAM7C,GAAG,GAAGD,KAAK,GAAGa,KAAK,CAAC,CAAC,CAAC,CAACtB,MAAM;YACnC,MAAM+B,SAAS,GAAGtB,KAAK,GAAGa,KAAK,CAAC,CAAC,CAAC,CAACO,OAAO,CAACP,KAAK,CAAC,CAAC,CAAC,CAAC;YACpD,MAAMW,OAAO,GAAGF,SAAS,GAAGT,KAAK,CAAC,CAAC,CAAC,CAACtB,MAAM;YAC3C,MAAMuB,KAAK,GAAGF,QAAQ,YAAYG,QAAQ,GAAGH,QAAQ,CAACC,KAAK,CAAC,GAAGD,QAAQ,CAAC,CAAC;;YAEzE,IAAIZ,KAAK,GAAG,CAAC,EAAE;cACbyC,KAAK,CAACM,IAAI,CAACJ,KAAK,CAACK,GAAG,CAACnD,GAAG,EAAEG,KAAK,CAAC,CAAC;YACnC,CAAC,CAAC;;YAGFyC,KAAK,CAACM,IAAI,CAACJ,KAAK,CAACK,GAAG,CAAC1B,SAAS,EAAEE,OAAO,CAAC,CAACjB,IAAI,CAACsB,IAAI,CAACK,MAAM,CAACpB,KAAK,CAAC,CAACmC,QAAQ,CAACN,KAAK,CAACzC,KAAK,CAAC,CAAC,CAAC;YACxFL,GAAG,GAAGI,GAAG;UACX;QACF,CAAC,CAAC;;QAGF,IAAIJ,GAAG,GAAGR,IAAI,CAACE,MAAM,EAAE;UACrBkD,KAAK,CAACM,IAAI,CAACJ,KAAK,CAACK,GAAG,CAACnD,GAAG,CAAC,CAAC;QAC5B;MACF,CAAC,MAAM;QACL4C,KAAK,CAACM,IAAI,CAACJ,KAAK,CAACO,IAAI,CAACX,OAAO,CAACI,KAAK,CAACQ,OAAO,EAAER,KAAK,CAAC,CAAC,CAAC;MACvD;IACF,CAAC,CAAC;IACF,OAAO3D,QAAQ,CAACoE,SAAS,CAACX,KAAK,CAAC;EAClC,CAAC;EAED,OAAO,IAAI3D,MAAM,CAAC;IAChBuE,KAAK,EAAE;MACLC,eAAe,EAAEC,KAAK,IAAI,IAAIxE,KAAK,CAACwD,OAAO,CAACgB,KAAK,CAACJ,OAAO,CAAC,EAAEI,KAAK,CAACC,SAAS,EAAED,KAAK,CAACE,OAAO;IAC5F;EACF,CAAC,CAAC;AACJ;AAEA,SAASM,UAAUA,CAAElC,IAAI,EAAE;EACzB,OAAO,CAACpC,KAAK,EAAEC,QAAQ,KAAK;IAC1B,MAAM;MACJI,EAAE;MACFF;IACF,CAAC,GAAGH,KAAK;IACT,IAAI;MACFuE,IAAI;MACJC;IACF,CAAC,GAAGrE,SAAS;IACb,MAAM;MACJD,KAAK;MACLuE;IACF,CAAC,GAAGtE,SAAS;IAEb,IAAIsE,KAAK,EAAE;MACT,MAAMC,KAAK,GAAGlF,YAAY,CAACU,KAAK,EAAEkC,IAAI,CAAC;MACvCmC,IAAI,GAAGG,KAAK,CAACH,IAAI;MACjBC,EAAE,GAAGE,KAAK,CAACF,EAAE;IACf;IAEAnE,EAAE,CAACiE,UAAU,CAACC,IAAI,EAAEC,EAAE,EAAEpC,IAAI,CAAC;IAC7B,OAAOnC,QAAQ,CAACI,EAAE,CAAC;EACrB,CAAC;AACH;AAEA,SAASsE,WAAWA,CAAA,EAA6D;EAAA,IAA3DD,KAAK,GAAA7E,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EAAA,IAAEuC,IAAI,GAAAvC,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAAEsB,KAAK,GAAAxB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAAA,IAAEkD,QAAQ,GAAAlD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGN,QAAQ,CAACkF,KAAK;EAC7E,OAAO,CAACzE,KAAK,EAAEC,QAAQ,KAAK;IAC1B,MAAM;MACJC,KAAK;MACL0E;IACF,CAAC,GAAG5E,KAAK,CAACG,SAAS;IACnB,MAAMkD,KAAK,GAAGnD,KAAK,CAACmD,KAAK,CAAC,CAAC;IAC3B,MAAMkB,IAAI,GAAGG,KAAK,GAAGA,KAAK,CAACH,IAAI,GAAGrE,KAAK,CAACE,GAAG;IAC3C,MAAMoE,EAAE,GAAGE,KAAK,GAAGA,KAAK,CAACF,EAAE,GAAGI,GAAG,CAACxE,GAAG;IAErC,IAAI,CAACF,KAAK,CAACgE,MAAM,CAACW,cAAc,CAACxB,KAAK,EAAEA,KAAK,EAAEjB,IAAI,CAAC,EAAE;MACpD,OAAO,KAAK;IACd;IAEA,IAAInC,QAAQ,EAAE;MACZA,QAAQ,CAACD,KAAK,CAACK,EAAE,CAACuC,WAAW,CAAC2B,IAAI,EAAEC,EAAE,EAAEpC,IAAI,CAACK,MAAM,CAACpB,KAAK,EAAE0B,QAAQ,CAAC,CAAC,CAAC;IACxE;IAEA,OAAO,IAAI;EACb,CAAC;AACH;AAEA,SAAS+B,kBAAkBA,CAAE1C,IAAI,EAAc;EAAA,IAAZf,KAAK,GAAAxB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAC3C,OAAO,CAACG,KAAK,EAAEC,QAAQ,KAAK;IAC1B,MAAM;MACJC;IACF,CAAC,GAAGF,KAAK,CAACG,SAAS;IACnB,MAAMkD,KAAK,GAAGnD,KAAK,CAACmD,KAAK,CAAC,CAAC;IAE3B,IAAI,CAACnD,KAAK,CAACgE,MAAM,CAACW,cAAc,CAACxB,KAAK,EAAEA,KAAK,EAAEjB,IAAI,CAAC,EAAE;MACpD,OAAO,KAAK;IACd;IAEA,IAAInC,QAAQ,EAAE;MACZA,QAAQ,CAACD,KAAK,CAACK,EAAE,CAAC0E,oBAAoB,CAAC3C,IAAI,CAACK,MAAM,CAACpB,KAAK,CAAC,CAAC,CAAC;IAC7D;IAEA,OAAO,IAAI;EACb,CAAC;AACH;;AAEA;AACA;;AAEA;;AAEA,SAAS2D,QAAQA,CAACtE,GAAG,EAAEN,GAAG,EAAyB;EAAA,IAAvB6E,KAAK,GAAApF,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAAA,IAAEqF,UAAU,GAAArF,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAC/C,MAAMoF,IAAI,GAAGzE,GAAG,CAAC0E,OAAO,CAAChF,GAAG,CAAC;EAC7B,MAAMiF,IAAI,GAAGF,IAAI,CAACF,KAAK,GAAGA,KAAK;EAC/B,MAAMK,SAAS,GAAGJ,UAAU,IAAIA,UAAU,CAACA,UAAU,CAACpF,MAAM,GAAG,CAAC,CAAC,IAAIqF,IAAI,CAACjB,MAAM;EAChF,IAAImB,IAAI,GAAG,CAAC,IAAIF,IAAI,CAACjB,MAAM,CAAC9B,IAAI,CAACmD,IAAI,CAACC,SAAS,IAAI,CAACL,IAAI,CAACjB,MAAM,CAACuB,UAAU,CAACN,IAAI,CAAC9B,KAAK,CAAC,CAAC,EAAE8B,IAAI,CAACjB,MAAM,CAACwB,UAAU,CAAC,IAAI,CAACJ,SAAS,CAAClD,IAAI,CAACuD,YAAY,CAACR,IAAI,CAACjB,MAAM,CAACR,OAAO,CAACkC,UAAU,CAACT,IAAI,CAAC9B,KAAK,CAAC,CAAC,EAAE8B,IAAI,CAACjB,MAAM,CAACwB,UAAU,CAAC,CAAC,EAAE,OAAO,KAAK;EAEpO,KAAK,IAAIG,CAAC,GAAGV,IAAI,CAACF,KAAK,GAAG,CAAC,EAAEa,CAAC,GAAGb,KAAK,GAAG,CAAC,EAAEY,CAAC,GAAGR,IAAI,EAAEQ,CAAC,EAAE,EAAEC,CAAC,EAAE,EAAE;IAC9D,MAAMlF,IAAI,GAAGuE,IAAI,CAACvE,IAAI,CAACiF,CAAC,CAAC;IACzB,MAAMxC,KAAK,GAAG8B,IAAI,CAAC9B,KAAK,CAACwC,CAAC,CAAC;IAC3B,IAAIjF,IAAI,CAACwB,IAAI,CAACmD,IAAI,CAACC,SAAS,EAAE,OAAO,KAAK;IAC1C,IAAIO,IAAI,GAAGnF,IAAI,CAAC8C,OAAO,CAACkC,UAAU,CAACvC,KAAK,EAAEzC,IAAI,CAAC8E,UAAU,CAAC;IAC1D,MAAMM,KAAK,GAAGd,UAAU,IAAIA,UAAU,CAACY,CAAC,CAAC,IAAIlF,IAAI;IACjD,IAAIoF,KAAK,IAAIpF,IAAI,EAAEmF,IAAI,GAAGA,IAAI,CAACE,YAAY,CAAC,CAAC,EAAED,KAAK,CAAC5D,IAAI,CAACK,MAAM,CAACuD,KAAK,CAAC3E,KAAK,CAAC,CAAC;IAC9E;IACA;IACA;;IAEA,IAAI,CAACT,IAAI,CAAC6E,UAAU,CAACpC,KAAK,GAAG,CAAC,EAAEzC,IAAI,CAAC8E,UAAU,CAAC,EAAE,OAAO,KAAK;IAC9D;EACF;;EAEA,MAAMrC,KAAK,GAAG8B,IAAI,CAACe,UAAU,CAACb,IAAI,CAAC;EACnC,MAAMc,QAAQ,GAAGjB,UAAU,IAAIA,UAAU,CAAC,CAAC,CAAC;EAC5C,OAAOC,IAAI,CAACvE,IAAI,CAACyE,IAAI,CAAC,CAACR,cAAc,CAACxB,KAAK,EAAEA,KAAK,EAAE8C,QAAQ,GAAGA,QAAQ,CAAC/D,IAAI,GAAG+C,IAAI,CAACvE,IAAI,CAACyE,IAAI,GAAG,CAAC,CAAC,CAACjD,IAAI,CAAC;AAC1G,CAAC,CAAC;AACF;;AAGA,SAASgE,sBAAsBA,CAACC,QAAQ,EAAE;EACxC,OAAO,UAAUrG,KAAK,EAAEC,QAAQ,EAAE;IAChC,MAAM;MACJC,KAAK;MACL0E,GAAG;MACHhE;IACF,CAAC,GAAGZ,KAAK,CAACG,SAAS;IACnB,IAAIS,IAAI,IAAIA,IAAI,CAAC0F,OAAO,IAAIpG,KAAK,CAAC+E,KAAK,GAAG,CAAC,IAAI,CAAC/E,KAAK,CAACqG,UAAU,CAAC3B,GAAG,CAAC,EAAE,OAAO,KAAK;IACnF,MAAM4B,WAAW,GAAGtG,KAAK,CAACU,IAAI,CAAC,CAAC,CAAC,CAAC;IAClC,IAAI4F,WAAW,CAACpE,IAAI,IAAIiE,QAAQ,EAAE,OAAO,KAAK;IAE9C,IAAInG,KAAK,CAACgE,MAAM,CAACR,OAAO,CAAC+C,IAAI,IAAI,CAAC,EAAE;MAClC;MACA;MACA;MACA,IAAIvG,KAAK,CAAC+E,KAAK,IAAI,CAAC,IAAI/E,KAAK,CAACU,IAAI,CAAC,CAAC,CAAC,CAAC,CAACwB,IAAI,IAAIiE,QAAQ,IAAInG,KAAK,CAACmD,KAAK,CAAC,CAAC,CAAC,CAAC,IAAInD,KAAK,CAACU,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC8E,UAAU,GAAG,CAAC,EAAE,OAAO,KAAK;MAEzH,IAAIzF,QAAQ,EAAE;QACZ,IAAIyG,IAAI,GAAGnH,QAAQ,CAACkF,KAAK;QACzB,MAAMkC,QAAQ,GAAGzG,KAAK,CAACmD,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QACtC;;QAEA,KAAK,IAAIwC,CAAC,GAAG3F,KAAK,CAAC+E,KAAK,IAAI0B,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEd,CAAC,IAAI3F,KAAK,CAAC+E,KAAK,GAAG,CAAC,EAAEY,CAAC,EAAE,EAAEa,IAAI,GAAGnH,QAAQ,CAACgF,IAAI,CAACrE,KAAK,CAACU,IAAI,CAACiF,CAAC,CAAC,CAACpC,IAAI,CAACiD,IAAI,CAAC,CAAC,CAAC,CAAC;;QAG1HA,IAAI,GAAGA,IAAI,CAACE,MAAM,CAACrH,QAAQ,CAACgF,IAAI,CAAC8B,QAAQ,CAACQ,aAAa,CAAC,CAAC,CAAC,CAAC;QAC3D,MAAMxG,EAAE,GAAGL,KAAK,CAACK,EAAE,CAACyG,OAAO,CAAC5G,KAAK,CAAC6G,MAAM,CAACJ,QAAQ,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC,EAAEzG,KAAK,CAAC8F,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI1G,KAAK,CAACoH,IAAI,EAAEC,QAAQ,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;QACtHtG,EAAE,CAAC2G,YAAY,CAAChH,KAAK,CAACG,SAAS,CAAC8G,WAAW,CAACC,IAAI,CAAC7G,EAAE,CAACK,GAAG,CAAC0E,OAAO,CAAClF,KAAK,CAACE,GAAG,IAAIuG,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QACjG1G,QAAQ,CAACI,EAAE,CAAC8G,cAAc,CAAC,CAAC,CAAC;MAC/B;MAEA,OAAO,IAAI;IACb;IAEA,MAAMC,QAAQ,GAAGxC,GAAG,CAACxE,GAAG,IAAIF,KAAK,CAACM,GAAG,CAAC,CAAC,GAAGgG,WAAW,CAACa,cAAc,CAACnH,KAAK,CAACgG,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAACoB,WAAW,GAAG,IAAI;IAC7G,MAAMjH,EAAE,GAAGL,KAAK,CAACK,EAAE,CAACkC,MAAM,CAACrC,KAAK,CAACE,GAAG,EAAEwE,GAAG,CAACxE,GAAG,CAAC;IAC9C;IACA;;IAEA,IAAImH,KAAK,GAAGH,QAAQ,IAAI,CAAC;MACvBhF,IAAI,EAAEiE;IACR,CAAC,EAAE;MACDjE,IAAI,EAAEgF;IACR,CAAC,CAAC;IACF,IAAI,CAACG,KAAK,EAAEA,KAAK,GAAG,CAAC;MACnBnF,IAAI,EAAEiE;IACR,CAAC,EAAE,IAAI,CAAC;IACR;;IAEA,IAAI,CAACrB,QAAQ,CAAC3E,EAAE,CAACK,GAAG,EAAER,KAAK,CAACE,GAAG,EAAE,CAAC,EAAEmH,KAAK,CAAC,EAAE,OAAO,KAAK;IACxD,IAAItH,QAAQ,EAAEA,QAAQ,CAACI,EAAE,CAACmH,KAAK,CAACtH,KAAK,CAACE,GAAG,EAAE,CAAC,EAAEmH,KAAK,CAAC,CAACJ,cAAc,CAAC,CAAC,CAAC;IACtE,OAAO,IAAI;EACb,CAAC;AACH;AACA;;AAEA,SAASM,eAAeA,CAAErF,IAAI,EAAEsF,UAAU,EAAc;EAAA,IAAZrG,KAAK,GAAAxB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACpD,OAAO,CAACG,KAAK,EAAEC,QAAQ,EAAE0H,IAAI,KAAK;IAChC,MAAMC,QAAQ,GAAGnI,YAAY,CAACO,KAAK,EAAEoC,IAAI,EAAEf,KAAK,CAAC;IAEjD,IAAIuG,QAAQ,EAAE;MACZ,OAAOvK,YAAY,CAACqK,UAAU,CAAC,CAAC1H,KAAK,EAAEC,QAAQ,EAAE0H,IAAI,CAAC;IACxD;IAEA,OAAOtK,YAAY,CAAC+E,IAAI,EAAEf,KAAK,CAAC,CAACrB,KAAK,EAAEC,QAAQ,EAAE0H,IAAI,CAAC;EACzD,CAAC;AACH;AAEA,SAASE,MAAMA,CAACjH,IAAI,EAAEkH,MAAM,EAAE;EAC5B,OAAOlH,IAAI,CAACwB,IAAI,KAAK0F,MAAM,CAAC9E,KAAK,CAAC+E,WAAW,IAAInH,IAAI,CAACwB,IAAI,KAAK0F,MAAM,CAAC9E,KAAK,CAACgF,YAAY,IAAIpH,IAAI,CAACwB,IAAI,KAAK0F,MAAM,CAAC9E,KAAK,CAACiF,SAAS;AAClI;AAEA,SAASC,UAAUA,CAACC,QAAQ,EAAE9B,QAAQ,EAAE;EACtC,OAAO,CAACrG,KAAK,EAAEC,QAAQ,EAAE0H,IAAI,KAAK;IAChC,MAAM;MACJG,MAAM;MACN3H;IACF,CAAC,GAAGH,KAAK;IACT,MAAM;MACJE,KAAK;MACL0E;IACF,CAAC,GAAGzE,SAAS;IACb,MAAMuE,KAAK,GAAGxE,KAAK,CAACkI,UAAU,CAACxD,GAAG,CAAC;IAEnC,IAAI,CAACF,KAAK,EAAE;MACV,OAAO,KAAK;IACd;IAEA,MAAM2D,UAAU,GAAG3I,cAAc,CAACkB,IAAI,IAAIiH,MAAM,CAACjH,IAAI,EAAEkH,MAAM,CAAC,CAAC,CAAC3H,SAAS,CAAC;IAE1E,IAAIuE,KAAK,CAACO,KAAK,IAAI,CAAC,IAAIoD,UAAU,IAAI3D,KAAK,CAACO,KAAK,GAAGoD,UAAU,CAACpD,KAAK,IAAI,CAAC,EAAE;MACzE,IAAIoD,UAAU,CAACzH,IAAI,CAACwB,IAAI,KAAK+F,QAAQ,EAAE;QACrC,OAAOtJ,YAAY,CAACwH,QAAQ,CAAC,CAACrG,KAAK,EAAEC,QAAQ,EAAE0H,IAAI,CAAC;MACtD;MAEA,IAAIE,MAAM,CAACQ,UAAU,CAACzH,IAAI,EAAEkH,MAAM,CAAC,IAAIK,QAAQ,CAACxC,YAAY,CAAC0C,UAAU,CAACzH,IAAI,CAAC8C,OAAO,CAAC,EAAE;QACrF,MAAM;UACJrD;QACF,CAAC,GAAGL,KAAK;QACTK,EAAE,CAACiI,aAAa,CAACD,UAAU,CAACjI,GAAG,EAAE+H,QAAQ,CAAC;QAE1C,IAAIlI,QAAQ,EAAE;UACZA,QAAQ,CAACI,EAAE,CAAC;QACd;QAEA,OAAO,KAAK;MACd;IACF;IAEA,OAAOvB,UAAU,CAACqJ,QAAQ,CAAC,CAACnI,KAAK,EAAEC,QAAQ,EAAE0H,IAAI,CAAC;EACpD,CAAC;AACH;AAEA,SAASY,UAAUA,CAAEnG,IAAI,EAAc;EAAA,IAAZf,KAAK,GAAAxB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACnC,OAAO,CAACG,KAAK,EAAEC,QAAQ,EAAE0H,IAAI,KAAK;IAChC,MAAMC,QAAQ,GAAGnI,YAAY,CAACO,KAAK,EAAEoC,IAAI,EAAEf,KAAK,CAAC;IAEjD,IAAIuG,QAAQ,EAAE;MACZ,OAAOtK,IAAI,CAAC0C,KAAK,EAAEC,QAAQ,CAAC;IAC9B;IAEA,OAAO1C,MAAM,CAAC6E,IAAI,EAAEf,KAAK,CAAC,CAACrB,KAAK,EAAEC,QAAQ,EAAE0H,IAAI,CAAC;EACnD,CAAC;AACH;AAEA,SAASa,UAAUA,CAAEpG,IAAI,EAAEf,KAAK,EAAE;EAChC,OAAO,CAACrB,KAAK,EAAEC,QAAQ,KAAK;IAC1B,MAAM;MACJI,EAAE;MACFF,SAAS;MACTO;IACF,CAAC,GAAGV,KAAK;IACT,MAAM;MACJyI,MAAM;MACNhE;IACF,CAAC,GAAGtE,SAAS;IAEb,IAAIsE,KAAK,EAAE;MACT,MAAM;QACJF,IAAI;QACJC;MACF,CAAC,GAAGhF,YAAY,CAACW,SAAS,CAACD,KAAK,EAAEkC,IAAI,CAAC;MAEvC,IAAI1B,GAAG,CAACgI,YAAY,CAACnE,IAAI,EAAEC,EAAE,EAAEpC,IAAI,CAAC,EAAE;QACpC/B,EAAE,CAACiE,UAAU,CAACC,IAAI,EAAEC,EAAE,EAAEpC,IAAI,CAAC;MAC/B;MAEA/B,EAAE,CAACmC,OAAO,CAAC+B,IAAI,EAAEC,EAAE,EAAEpC,IAAI,CAACK,MAAM,CAACpB,KAAK,CAAC,CAAC;IAC1C,CAAC,MAAM;MACLoH,MAAM,CAACxF,OAAO,CAAC0F,KAAK,IAAI;QACtB,MAAM;UACJ/D,GAAG;UACH1E;QACF,CAAC,GAAGyI,KAAK;QAET,IAAIjI,GAAG,CAACgI,YAAY,CAACxI,KAAK,CAACE,GAAG,EAAEwE,GAAG,CAACxE,GAAG,EAAEgC,IAAI,CAAC,EAAE;UAC9C/B,EAAE,CAACiE,UAAU,CAACpE,KAAK,CAACE,GAAG,EAAEwE,GAAG,CAACxE,GAAG,EAAEgC,IAAI,CAAC;QACzC;QAEA/B,EAAE,CAACmC,OAAO,CAACtC,KAAK,CAACE,GAAG,EAAEwE,GAAG,CAACxE,GAAG,EAAEgC,IAAI,CAACK,MAAM,CAACpB,KAAK,CAAC,CAAC;MACpD,CAAC,CAAC;IACJ;IAEA,OAAOpB,QAAQ,CAACI,EAAE,CAAC;EACrB,CAAC;AACH;AAEA,SAASV,UAAU,EAAEqB,aAAa,EAAEiD,aAAa,EAAEtB,aAAa,EAAEE,SAAS,EAAEyB,UAAU,EAAEK,WAAW,EAAEG,kBAAkB,EAAEsB,sBAAsB,EAAEqB,eAAe,EAAES,UAAU,EAAEK,UAAU,EAAEC,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}