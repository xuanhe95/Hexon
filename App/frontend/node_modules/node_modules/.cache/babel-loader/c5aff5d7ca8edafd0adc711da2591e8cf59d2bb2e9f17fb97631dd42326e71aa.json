{"ast":null,"code":"import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' â€” a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n  constructor(items, eventCount) {\n    this.items = items;\n    this.eventCount = eventCount;\n  }\n  // Pop the latest event off the branch's history and apply it\n  // to a document transform.\n  popEvent(state, preserveItems) {\n    if (this.eventCount == 0) return null;\n    let end = this.items.length;\n    for (;; end--) {\n      let next = this.items.get(end - 1);\n      if (next.selection) {\n        --end;\n        break;\n      }\n    }\n    let remap, mapFrom;\n    if (preserveItems) {\n      remap = this.remapping(end, this.items.length);\n      mapFrom = remap.maps.length;\n    }\n    let transform = state.tr;\n    let selection, remaining;\n    let addAfter = [],\n      addBefore = [];\n    this.items.forEach((item, i) => {\n      if (!item.step) {\n        if (!remap) {\n          remap = this.remapping(end, i + 1);\n          mapFrom = remap.maps.length;\n        }\n        mapFrom--;\n        addBefore.push(item);\n        return;\n      }\n      if (remap) {\n        addBefore.push(new Item(item.map));\n        let step = item.step.map(remap.slice(mapFrom)),\n          map;\n        if (step && transform.maybeStep(step).doc) {\n          map = transform.mapping.maps[transform.mapping.maps.length - 1];\n          addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n        }\n        mapFrom--;\n        if (map) remap.appendMap(map, mapFrom);\n      } else {\n        transform.maybeStep(item.step);\n      }\n      if (item.selection) {\n        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n        return false;\n      }\n    }, this.items.length, 0);\n    return {\n      remaining: remaining,\n      transform,\n      selection: selection\n    };\n  }\n  // Create a new branch with the given transform added.\n  addTransform(transform, selection, histOptions, preserveItems) {\n    let newItems = [],\n      eventCount = this.eventCount;\n    let oldItems = this.items,\n      lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n    for (let i = 0; i < transform.steps.length; i++) {\n      let step = transform.steps[i].invert(transform.docs[i]);\n      let item = new Item(transform.mapping.maps[i], step, selection),\n        merged;\n      if (merged = lastItem && lastItem.merge(item)) {\n        item = merged;\n        if (i) newItems.pop();else oldItems = oldItems.slice(0, oldItems.length - 1);\n      }\n      newItems.push(item);\n      if (selection) {\n        eventCount++;\n        selection = undefined;\n      }\n      if (!preserveItems) lastItem = item;\n    }\n    let overflow = eventCount - histOptions.depth;\n    if (overflow > DEPTH_OVERFLOW) {\n      oldItems = cutOffEvents(oldItems, overflow);\n      eventCount -= overflow;\n    }\n    return new Branch(oldItems.append(newItems), eventCount);\n  }\n  remapping(from, to) {\n    let maps = new Mapping();\n    this.items.forEach((item, i) => {\n      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : undefined;\n      maps.appendMap(item.map, mirrorPos);\n    }, from, to);\n    return maps;\n  }\n  addMaps(array) {\n    if (this.eventCount == 0) return this;\n    return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n  }\n  // When the collab module receives remote changes, the history has\n  // to know about those, so that it can adjust the steps that were\n  // rebased on top of the remote changes, and include the position\n  // maps for the remote changes in its array of items.\n  rebased(rebasedTransform, rebasedCount) {\n    if (!this.eventCount) return this;\n    let rebasedItems = [],\n      start = Math.max(0, this.items.length - rebasedCount);\n    let mapping = rebasedTransform.mapping;\n    let newUntil = rebasedTransform.steps.length;\n    let eventCount = this.eventCount;\n    this.items.forEach(item => {\n      if (item.selection) eventCount--;\n    }, start);\n    let iRebased = rebasedCount;\n    this.items.forEach(item => {\n      let pos = mapping.getMirror(--iRebased);\n      if (pos == null) return;\n      newUntil = Math.min(newUntil, pos);\n      let map = mapping.maps[pos];\n      if (item.step) {\n        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n        if (selection) eventCount++;\n        rebasedItems.push(new Item(map, step, selection));\n      } else {\n        rebasedItems.push(new Item(map));\n      }\n    }, start);\n    let newMaps = [];\n    for (let i = rebasedCount; i < newUntil; i++) newMaps.push(new Item(mapping.maps[i]));\n    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n    let branch = new Branch(items, eventCount);\n    if (branch.emptyItemCount() > max_empty_items) branch = branch.compress(this.items.length - rebasedItems.length);\n    return branch;\n  }\n  emptyItemCount() {\n    let count = 0;\n    this.items.forEach(item => {\n      if (!item.step) count++;\n    });\n    return count;\n  }\n  // Compressing a branch means rewriting it to push the air (map-only\n  // items) out. During collaboration, these naturally accumulate\n  // because each remote change adds one. The `upto` argument is used\n  // to ensure that only the items below a given level are compressed,\n  // because `rebased` relies on a clean, untouched set of items in\n  // order to associate old items with rebased steps.\n  compress() {\n    let upto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n    let remap = this.remapping(0, upto),\n      mapFrom = remap.maps.length;\n    let items = [],\n      events = 0;\n    this.items.forEach((item, i) => {\n      if (i >= upto) {\n        items.push(item);\n        if (item.selection) events++;\n      } else if (item.step) {\n        let step = item.step.map(remap.slice(mapFrom)),\n          map = step && step.getMap();\n        mapFrom--;\n        if (map) remap.appendMap(map, mapFrom);\n        if (step) {\n          let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n          if (selection) events++;\n          let newItem = new Item(map.invert(), step, selection),\n            merged,\n            last = items.length - 1;\n          if (merged = items.length && items[last].merge(newItem)) items[last] = merged;else items.push(newItem);\n        }\n      } else if (item.map) {\n        mapFrom--;\n      }\n    }, this.items.length, 0);\n    return new Branch(RopeSequence.from(items.reverse()), events);\n  }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n  let cutPoint;\n  items.forEach((item, i) => {\n    if (item.selection && n-- == 0) {\n      cutPoint = i;\n      return false;\n    }\n  });\n  return items.slice(cutPoint);\n}\nclass Item {\n  constructor(\n  // The (forward) step map for this item.\n  map,\n  // The inverted step\n  step,\n  // If this is non-null, this item is the start of a group, and\n  // this selection is the starting selection for the group (the one\n  // that was active before the first step was applied)\n  selection,\n  // If this item is the inverse of a previous mapping on the stack,\n  // this points at the inverse's offset\n  mirrorOffset) {\n    this.map = map;\n    this.step = step;\n    this.selection = selection;\n    this.mirrorOffset = mirrorOffset;\n  }\n  merge(other) {\n    if (this.step && other.step && !other.selection) {\n      let step = other.step.merge(this.step);\n      if (step) return new Item(step.getMap().invert(), step, this.selection);\n    }\n  }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n  constructor(done, undone, prevRanges, prevTime, prevComposition) {\n    this.done = done;\n    this.undone = undone;\n    this.prevRanges = prevRanges;\n    this.prevTime = prevTime;\n    this.prevComposition = prevComposition;\n  }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n  let historyTr = tr.getMeta(historyKey),\n    rebased;\n  if (historyTr) return historyTr.historyState;\n  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0, -1);\n  let appended = tr.getMeta(\"appendedTransaction\");\n  if (tr.steps.length == 0) {\n    return history;\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo) return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime, history.prevComposition);else return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    let composition = tr.getMeta(\"composition\");\n    let newGroup = history.prevTime == 0 || !appended && history.prevComposition != composition && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));\n    let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n  }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) return false;\n  if (!transform.docChanged) return true;\n  let adjacent = false;\n  transform.mapping.maps[0].forEach((start, end) => {\n    for (let i = 0; i < prevRanges.length; i += 2) if (start <= prevRanges[i + 1] && end >= prevRanges[i]) adjacent = true;\n  });\n  return adjacent;\n}\nfunction rangesFor(map) {\n  let result = [];\n  map.forEach((_from, _to, from, to) => result.push(from, to));\n  return result;\n}\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) return null;\n  let result = [];\n  for (let i = 0; i < ranges.length; i += 2) {\n    let from = mapping.map(ranges[i], 1),\n      to = mapping.map(ranges[i + 1], -1);\n    if (from <= to) result.push(from, to);\n  }\n  return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n  let preserveItems = mustPreserveItems(state);\n  let histOptions = historyKey.get(state).spec.config;\n  let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n  if (!pop) return;\n  let selection = pop.selection.resolve(pop.transform.doc);\n  let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n  let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {\n    redo,\n    historyState: newHist\n  }).scrollIntoView());\n}\nlet cachedPreserveItems = false,\n  cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n  let plugins = state.plugins;\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false;\n    cachedPreserveItemsPlugins = plugins;\n    for (let i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true;\n      break;\n    }\n  }\n  return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  config = {\n    depth: config.depth || 100,\n    newGroupDelay: config.newGroupDelay || 500\n  };\n  return new Plugin({\n    key: historyKey,\n    state: {\n      init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n      },\n      apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config);\n      }\n    },\n    config,\n    props: {\n      handleDOMEvents: {\n        beforeinput(view, e) {\n          let inputType = e.inputType;\n          let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n          if (!command) return false;\n          e.preventDefault();\n          return command(view.state, view.dispatch);\n        }\n      }\n    }\n  });\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = (state, dispatch) => {\n  let hist = historyKey.getState(state);\n  if (!hist || hist.done.eventCount == 0) return false;\n  if (dispatch) histTransaction(hist, state, dispatch, false);\n  return true;\n};\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = (state, dispatch) => {\n  let hist = historyKey.getState(state);\n  if (!hist || hist.undone.eventCount == 0) return false;\n  if (dispatch) histTransaction(hist, state, dispatch, true);\n  return true;\n};\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n  let hist = historyKey.getState(state);\n  return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n  let hist = historyKey.getState(state);\n  return hist ? hist.undone.eventCount : 0;\n}\nexport { closeHistory, history, redo, redoDepth, undo, undoDepth };","map":{"version":3,"names":["RopeSequence","Mapping","PluginKey","Plugin","max_empty_items","Branch","constructor","items","eventCount","popEvent","state","preserveItems","end","length","next","get","selection","remap","mapFrom","remapping","maps","transform","tr","remaining","addAfter","addBefore","forEach","item","i","step","push","Item","map","slice","maybeStep","doc","mapping","undefined","appendMap","append","reverse","concat","addTransform","histOptions","newItems","oldItems","lastItem","steps","invert","docs","merged","merge","pop","overflow","depth","DEPTH_OVERFLOW","cutOffEvents","from","to","mirrorPos","mirrorOffset","addMaps","array","rebased","rebasedTransform","rebasedCount","rebasedItems","start","Math","max","newUntil","iRebased","pos","getMirror","min","newMaps","branch","emptyItemCount","compress","count","upto","arguments","events","getMap","newItem","last","empty","n","cutPoint","other","HistoryState","done","undone","prevRanges","prevTime","prevComposition","applyTransaction","history","options","historyTr","getMeta","historyKey","historyState","closeHistoryKey","appended","redo","mustPreserveItems","rangesFor","composition","newGroup","time","newGroupDelay","isAdjacentTo","mapRanges","getBookmark","docChanged","adjacent","result","_from","_to","ranges","histTransaction","dispatch","spec","config","resolve","added","newHist","setSelection","setMeta","scrollIntoView","cachedPreserveItems","cachedPreserveItemsPlugins","plugins","historyPreserveItems","closeHistory","key","init","apply","hist","props","handleDOMEvents","beforeinput","view","e","inputType","command","undo","preventDefault","getState","undoDepth","redoDepth"],"sources":["/Users/xander/go/hexon/frontend/node_modules/prosemirror-history/dist/index.js"],"sourcesContent":["import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' â€” a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(RopeSequence.from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime, history.prevComposition);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta(\"composition\");\n        let newGroup = history.prevTime == 0 ||\n            (!appended && history.prevComposition != composition &&\n                (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges)));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(map) {\n    let result = [];\n    map.forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist }).scrollIntoView());\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || hist.done.eventCount == 0)\n        return false;\n    if (dispatch)\n        histTransaction(hist, state, dispatch, false);\n    return true;\n};\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || hist.undone.eventCount == 0)\n        return false;\n    if (dispatch)\n        histTransaction(hist, state, dispatch, true);\n    return true;\n};\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\nexport { closeHistory, history, redo, redoDepth, undo, undoDepth };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}