{"ast":null,"code":"import { Node, mergeAttributes, nodeInputRule } from '@tiptap/core';\nimport { TextSelection } from '@tiptap/pm/state';\nconst HorizontalRule = Node.create({\n  name: 'horizontalRule',\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  group: 'block',\n  parseHTML() {\n    return [{\n      tag: 'hr'\n    }];\n  },\n  renderHTML(_ref) {\n    let {\n      HTMLAttributes\n    } = _ref;\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  addCommands() {\n    return {\n      setHorizontalRule: () => _ref2 => {\n        let {\n          chain\n        } = _ref2;\n        return chain().insertContent({\n          type: this.name\n        })\n        // set cursor after horizontal rule\n        .command(_ref3 => {\n          let {\n            tr,\n            dispatch\n          } = _ref3;\n          var _a;\n          if (dispatch) {\n            const {\n              $to\n            } = tr.selection;\n            const posAfter = $to.end();\n            if ($to.nodeAfter) {\n              tr.setSelection(TextSelection.create(tr.doc, $to.pos));\n            } else {\n              // add node after horizontal rule if it’s the end of the document\n              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n              if (node) {\n                tr.insert(posAfter, node);\n                tr.setSelection(TextSelection.create(tr.doc, posAfter));\n              }\n            }\n            tr.scrollIntoView();\n          }\n          return true;\n        }).run();\n      }\n    };\n  },\n  addInputRules() {\n    return [nodeInputRule({\n      find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n      type: this.type\n    })];\n  }\n});\nexport { HorizontalRule, HorizontalRule as default };","map":{"version":3,"names":["HorizontalRule","Node","create","name","addOptions","HTMLAttributes","group","parseHTML","tag","renderHTML","_ref","mergeAttributes","options","addCommands","setHorizontalRule","_ref2","chain","insertContent","type","command","_ref3","tr","dispatch","$to","selection","posAfter","end","nodeAfter","setSelection","TextSelection","doc","pos","node","_a","parent","contentMatch","defaultType","insert","scrollIntoView","run","addInputRules","nodeInputRule","find"],"sources":["/Users/xander/go/hexon/frontend/node_modules/@tiptap/extension-horizontal-rule/src/horizontal-rule.ts"],"sourcesContent":["import { mergeAttributes, Node, nodeInputRule } from '@tiptap/core'\nimport { TextSelection } from '@tiptap/pm/state'\n\nexport interface HorizontalRuleOptions {\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       */\n      setHorizontalRule: () => ReturnType\n    }\n  }\n}\n\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'hr' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule:\n        () => ({ chain }) => {\n          return (\n            chain()\n              .insertContent({ type: this.name })\n              // set cursor after horizontal rule\n              .command(({ tr, dispatch }) => {\n                if (dispatch) {\n                  const { $to } = tr.selection\n                  const posAfter = $to.end()\n\n                  if ($to.nodeAfter) {\n                    tr.setSelection(TextSelection.create(tr.doc, $to.pos))\n                  } else {\n                    // add node after horizontal rule if it’s the end of the document\n                    const node = $to.parent.type.contentMatch.defaultType?.create()\n\n                    if (node) {\n                      tr.insert(posAfter, node)\n                      tr.setSelection(TextSelection.create(tr.doc, posAfter))\n                    }\n                  }\n\n                  tr.scrollIntoView()\n                }\n\n                return true\n              })\n              .run()\n          )\n        },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type,\n      }),\n    ]\n  },\n})\n"],"mappings":";;AAkBa,MAAAA,cAAc,GAAGC,IAAI,CAACC,MAAM,CAAwB;EAC/DC,IAAI,EAAE,gBAAgB;EAEtBC,UAAUA,CAAA;IACR,OAAO;MACLC,cAAc,EAAE;KACjB;GACF;EAEDC,KAAK,EAAE,OAAO;EAEdC,SAASA,CAAA;IACP,OAAO,CAAC;MAAEC,GAAG,EAAE;IAAI,CAAE,CAAC;GACvB;EAEDC,UAAUA,CAAAC,IAAA,EAAmB;IAAA,IAAlB;MAAEL;IAAc,CAAE,GAAAK,IAAA;IAC3B,OAAO,CAAC,IAAI,EAAEC,eAAe,CAAC,IAAI,CAACC,OAAO,CAACP,cAAc,EAAEA,cAAc,CAAC,CAAC;GAC5E;EAEDQ,WAAWA,CAAA;IACT,OAAO;MACLC,iBAAiB,EACfA,CAAA,KAAMC,KAAA,IAAc;QAAA,IAAb;UAAEC;QAAK,CAAE,GAAAD,KAAA;QACd,OACEC,KAAK,EAAE,CACJC,aAAa,CAAC;UAAEC,IAAI,EAAE,IAAI,CAACf;QAAI,CAAE;;SAEjCgB,OAAO,CAACC,KAAA,IAAqB;UAAA,IAApB;YAAEC,EAAE;YAAEC;UAAQ,CAAE,GAAAF,KAAA;;UACxB,IAAIE,QAAQ,EAAE;YACZ,MAAM;cAAEC;YAAG,CAAE,GAAGF,EAAE,CAACG,SAAS;YAC5B,MAAMC,QAAQ,GAAGF,GAAG,CAACG,GAAG,EAAE;YAE1B,IAAIH,GAAG,CAACI,SAAS,EAAE;cACjBN,EAAE,CAACO,YAAY,CAACC,aAAa,CAAC3B,MAAM,CAACmB,EAAE,CAACS,GAAG,EAAEP,GAAG,CAACQ,GAAG,CAAC,CAAC;YACvD,OAAM;;cAEL,MAAMC,IAAI,GAAG,CAAAC,EAAA,GAAAV,GAAG,CAACW,MAAM,CAAChB,IAAI,CAACiB,YAAY,CAACC,WAAW,MAAE,QAAAH,EAAA,uBAAAA,EAAA,CAAA/B,MAAM,EAAE;cAE/D,IAAI8B,IAAI,EAAE;gBACRX,EAAE,CAACgB,MAAM,CAACZ,QAAQ,EAAEO,IAAI,CAAC;gBACzBX,EAAE,CAACO,YAAY,CAACC,aAAa,CAAC3B,MAAM,CAACmB,EAAE,CAACS,GAAG,EAAEL,QAAQ,CAAC,CAAC;cACxD;YACF;YAEDJ,EAAE,CAACiB,cAAc,EAAE;UACpB;UAED,OAAO,IAAI;QACb,CAAC,CAAC,CACDC,GAAG,EAAE;;KAGf;GACF;EAEDC,aAAaA,CAAA;IACX,OAAO,CACLC,aAAa,CAAC;MACZC,IAAI,EAAE,6BAA6B;MACnCxB,IAAI,EAAE,IAAI,CAACA;KACZ,CAAC,CACH;;AAEJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}