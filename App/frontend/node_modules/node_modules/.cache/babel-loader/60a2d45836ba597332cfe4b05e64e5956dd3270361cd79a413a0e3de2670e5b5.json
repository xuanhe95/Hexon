{"ast":null,"code":"import { keydownHandler } from 'prosemirror-keymap';\nimport { Selection, NodeSelection, TextSelection, Plugin } from 'prosemirror-state';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/\nclass GapCursor extends Selection {\n  /**\n  Create a gap cursor.\n  */\n  constructor($pos) {\n    super($pos, $pos);\n  }\n  map(doc, mapping) {\n    let $pos = doc.resolve(mapping.map(this.head));\n    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n  }\n  content() {\n    return Slice.empty;\n  }\n  eq(other) {\n    return other instanceof GapCursor && other.head == this.head;\n  }\n  toJSON() {\n    return {\n      type: \"gapcursor\",\n      pos: this.head\n    };\n  }\n  /**\n  @internal\n  */\n  static fromJSON(doc, json) {\n    if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n    return new GapCursor(doc.resolve(json.pos));\n  }\n  /**\n  @internal\n  */\n  getBookmark() {\n    return new GapBookmark(this.anchor);\n  }\n  /**\n  @internal\n  */\n  static valid($pos) {\n    let parent = $pos.parent;\n    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false;\n    let override = parent.type.spec.allowGapCursor;\n    if (override != null) return override;\n    let deflt = parent.contentMatchAt($pos.index()).defaultType;\n    return deflt && deflt.isTextblock;\n  }\n  /**\n  @internal\n  */\n  static findGapCursorFrom($pos, dir) {\n    let mustMove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    search: for (;;) {\n      if (!mustMove && GapCursor.valid($pos)) return $pos;\n      let pos = $pos.pos,\n        next = null;\n      // Scan up from this position\n      for (let d = $pos.depth;; d--) {\n        let parent = $pos.node(d);\n        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n          break;\n        } else if (d == 0) {\n          return null;\n        }\n        pos += dir;\n        let $cur = $pos.doc.resolve(pos);\n        if (GapCursor.valid($cur)) return $cur;\n      }\n      // And then down into the next node\n      for (;;) {\n        let inside = dir > 0 ? next.firstChild : next.lastChild;\n        if (!inside) {\n          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n            mustMove = false;\n            continue search;\n          }\n          break;\n        }\n        next = inside;\n        pos += dir;\n        let $cur = $pos.doc.resolve(pos);\n        if (GapCursor.valid($cur)) return $cur;\n      }\n      return null;\n    }\n  }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nSelection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n  constructor(pos) {\n    this.pos = pos;\n  }\n  map(mapping) {\n    return new GapBookmark(mapping.map(this.pos));\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.pos);\n    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n  }\n}\nfunction closedBefore($pos) {\n  for (let d = $pos.depth; d >= 0; d--) {\n    let index = $pos.index(d),\n      parent = $pos.node(d);\n    // At the start of this parent, look at next one\n    if (index == 0) {\n      if (parent.type.spec.isolating) return true;\n      continue;\n    }\n    // See if the node before (or its first ancestor) is closed\n    for (let before = parent.child(index - 1);; before = before.lastChild) {\n      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating) return true;\n      if (before.inlineContent) return false;\n    }\n  }\n  // Hit start of document\n  return true;\n}\nfunction closedAfter($pos) {\n  for (let d = $pos.depth; d >= 0; d--) {\n    let index = $pos.indexAfter(d),\n      parent = $pos.node(d);\n    if (index == parent.childCount) {\n      if (parent.type.spec.isolating) return true;\n      continue;\n    }\n    for (let after = parent.child(index);; after = after.firstChild) {\n      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating) return true;\n      if (after.inlineContent) return false;\n    }\n  }\n  return true;\n}\n\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/\nfunction gapCursor() {\n  return new Plugin({\n    props: {\n      decorations: drawGapCursor,\n      createSelectionBetween(_view, $anchor, $head) {\n        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n      },\n      handleClick,\n      handleKeyDown,\n      handleDOMEvents: {\n        beforeinput: beforeinput\n      }\n    }\n  });\n}\nconst handleKeyDown = keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n  const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n  return function (state, dispatch, view) {\n    let sel = state.selection;\n    let $start = dir > 0 ? sel.$to : sel.$from,\n      mustMove = sel.empty;\n    if (sel instanceof TextSelection) {\n      if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false;\n      mustMove = false;\n      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n    }\n    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n    if (!$found) return false;\n    if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)));\n    return true;\n  };\n}\nfunction handleClick(view, pos, event) {\n  if (!view || !view.editable) return false;\n  let $pos = view.state.doc.resolve(pos);\n  if (!GapCursor.valid($pos)) return false;\n  let clickPos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside))) return false;\n  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n  return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n  if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor)) return false;\n  let {\n    $from\n  } = view.state.selection;\n  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n  if (!insert) return false;\n  let frag = Fragment.empty;\n  for (let i = insert.length - 1; i >= 0; i--) frag = Fragment.from(insert[i].createAndFill(null, frag));\n  let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));\n  tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));\n  view.dispatch(tr);\n  return false;\n}\nfunction drawGapCursor(state) {\n  if (!(state.selection instanceof GapCursor)) return null;\n  let node = document.createElement(\"div\");\n  node.className = \"ProseMirror-gapcursor\";\n  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, {\n    key: \"gapcursor\"\n  })]);\n}\nexport { GapCursor, gapCursor };","map":{"version":3,"names":["keydownHandler","Selection","NodeSelection","TextSelection","Plugin","Slice","Fragment","DecorationSet","Decoration","GapCursor","constructor","$pos","map","doc","mapping","resolve","head","valid","near","content","empty","eq","other","toJSON","type","pos","fromJSON","json","RangeError","getBookmark","GapBookmark","anchor","parent","isTextblock","closedBefore","closedAfter","override","spec","allowGapCursor","deflt","contentMatchAt","index","defaultType","findGapCursorFrom","dir","mustMove","arguments","length","undefined","search","next","d","depth","node","indexAfter","childCount","child","$cur","inside","firstChild","lastChild","isAtom","isText","isSelectable","nodeSize","prototype","visible","findFrom","jsonID","isolating","before","inlineContent","after","gapCursor","props","decorations","drawGapCursor","createSelectionBetween","_view","$anchor","$head","handleClick","handleKeyDown","handleDOMEvents","beforeinput","arrow","axis","dirStr","state","dispatch","view","sel","selection","$start","$to","$from","endOfTextblock","$found","tr","setSelection","event","editable","clickPos","posAtCoords","left","clientX","top","clientY","nodeAt","inputType","insert","findWrapping","schema","nodes","text","frag","i","from","createAndFill","replace","document","createElement","className","create","widget","key"],"sources":["/Users/xander/go/hexon/frontend/node_modules/prosemirror-gapcursor/dist/index.js"],"sourcesContent":["import { keydownHandler } from 'prosemirror-keymap';\nimport { Selection, NodeSelection, TextSelection, Plugin } from 'prosemirror-state';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/\nclass GapCursor extends Selection {\n    /**\n    Create a gap cursor.\n    */\n    constructor($pos) {\n        super($pos, $pos);\n    }\n    map(doc, mapping) {\n        let $pos = doc.resolve(mapping.map(this.head));\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n    content() { return Slice.empty; }\n    eq(other) {\n        return other instanceof GapCursor && other.head == this.head;\n    }\n    toJSON() {\n        return { type: \"gapcursor\", pos: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n        return new GapCursor(doc.resolve(json.pos));\n    }\n    /**\n    @internal\n    */\n    getBookmark() { return new GapBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static valid($pos) {\n        let parent = $pos.parent;\n        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))\n            return false;\n        let override = parent.type.spec.allowGapCursor;\n        if (override != null)\n            return override;\n        let deflt = parent.contentMatchAt($pos.index()).defaultType;\n        return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */\n    static findGapCursorFrom($pos, dir, mustMove = false) {\n        search: for (;;) {\n            if (!mustMove && GapCursor.valid($pos))\n                return $pos;\n            let pos = $pos.pos, next = null;\n            // Scan up from this position\n            for (let d = $pos.depth;; d--) {\n                let parent = $pos.node(d);\n                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n                    break;\n                }\n                else if (d == 0) {\n                    return null;\n                }\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            // And then down into the next node\n            for (;;) {\n                let inside = dir > 0 ? next.firstChild : next.lastChild;\n                if (!inside) {\n                    if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n                        mustMove = false;\n                        continue search;\n                    }\n                    break;\n                }\n                next = inside;\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            return null;\n        }\n    }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nSelection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n    constructor(pos) {\n        this.pos = pos;\n    }\n    map(mapping) {\n        return new GapBookmark(mapping.map(this.pos));\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.pos);\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n}\nfunction closedBefore($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.index(d), parent = $pos.node(d);\n        // At the start of this parent, look at next one\n        if (index == 0) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        // See if the node before (or its first ancestor) is closed\n        for (let before = parent.child(index - 1);; before = before.lastChild) {\n            if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating)\n                return true;\n            if (before.inlineContent)\n                return false;\n        }\n    }\n    // Hit start of document\n    return true;\n}\nfunction closedAfter($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.indexAfter(d), parent = $pos.node(d);\n        if (index == parent.childCount) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        for (let after = parent.child(index);; after = after.firstChild) {\n            if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating)\n                return true;\n            if (after.inlineContent)\n                return false;\n        }\n    }\n    return true;\n}\n\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/\nfunction gapCursor() {\n    return new Plugin({\n        props: {\n            decorations: drawGapCursor,\n            createSelectionBetween(_view, $anchor, $head) {\n                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n            },\n            handleClick,\n            handleKeyDown,\n            handleDOMEvents: { beforeinput: beforeinput }\n        }\n    });\n}\nconst handleKeyDown = keydownHandler({\n    \"ArrowLeft\": arrow(\"horiz\", -1),\n    \"ArrowRight\": arrow(\"horiz\", 1),\n    \"ArrowUp\": arrow(\"vert\", -1),\n    \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n    const dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\");\n    return function (state, dispatch, view) {\n        let sel = state.selection;\n        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n        if (sel instanceof TextSelection) {\n            if (!view.endOfTextblock(dirStr) || $start.depth == 0)\n                return false;\n            mustMove = false;\n            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n        }\n        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n        if (!$found)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(new GapCursor($found)));\n        return true;\n    };\n}\nfunction handleClick(view, pos, event) {\n    if (!view || !view.editable)\n        return false;\n    let $pos = view.state.doc.resolve(pos);\n    if (!GapCursor.valid($pos))\n        return false;\n    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))\n        return false;\n    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n    return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n    if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor))\n        return false;\n    let { $from } = view.state.selection;\n    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n    if (!insert)\n        return false;\n    let frag = Fragment.empty;\n    for (let i = insert.length - 1; i >= 0; i--)\n        frag = Fragment.from(insert[i].createAndFill(null, frag));\n    let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));\n    tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));\n    view.dispatch(tr);\n    return false;\n}\nfunction drawGapCursor(state) {\n    if (!(state.selection instanceof GapCursor))\n        return null;\n    let node = document.createElement(\"div\");\n    node.className = \"ProseMirror-gapcursor\";\n    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: \"gapcursor\" })]);\n}\n\nexport { GapCursor, gapCursor };\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,oBAAoB;AACnD,SAASC,SAAS,EAAEC,aAAa,EAAEC,aAAa,EAAEC,MAAM,QAAQ,mBAAmB;AACnF,SAASC,KAAK,EAAEC,QAAQ,QAAQ,mBAAmB;AACnD,SAASC,aAAa,EAAEC,UAAU,QAAQ,kBAAkB;;AAE5D;AACA;AACA;AACA;AACA,MAAMC,SAAS,SAASR,SAAS,CAAC;EAC9B;AACJ;AACA;EACIS,WAAWA,CAACC,IAAI,EAAE;IACd,KAAK,CAACA,IAAI,EAAEA,IAAI,CAAC;EACrB;EACAC,GAAGA,CAACC,GAAG,EAAEC,OAAO,EAAE;IACd,IAAIH,IAAI,GAAGE,GAAG,CAACE,OAAO,CAACD,OAAO,CAACF,GAAG,CAAC,IAAI,CAACI,IAAI,CAAC,CAAC;IAC9C,OAAOP,SAAS,CAACQ,KAAK,CAACN,IAAI,CAAC,GAAG,IAAIF,SAAS,CAACE,IAAI,CAAC,GAAGV,SAAS,CAACiB,IAAI,CAACP,IAAI,CAAC;EAC7E;EACAQ,OAAOA,CAAA,EAAG;IAAE,OAAOd,KAAK,CAACe,KAAK;EAAE;EAChCC,EAAEA,CAACC,KAAK,EAAE;IACN,OAAOA,KAAK,YAAYb,SAAS,IAAIa,KAAK,CAACN,IAAI,IAAI,IAAI,CAACA,IAAI;EAChE;EACAO,MAAMA,CAAA,EAAG;IACL,OAAO;MAAEC,IAAI,EAAE,WAAW;MAAEC,GAAG,EAAE,IAAI,CAACT;IAAK,CAAC;EAChD;EACA;AACJ;AACA;EACI,OAAOU,QAAQA,CAACb,GAAG,EAAEc,IAAI,EAAE;IACvB,IAAI,OAAOA,IAAI,CAACF,GAAG,IAAI,QAAQ,EAC3B,MAAM,IAAIG,UAAU,CAAC,sCAAsC,CAAC;IAChE,OAAO,IAAInB,SAAS,CAACI,GAAG,CAACE,OAAO,CAACY,IAAI,CAACF,GAAG,CAAC,CAAC;EAC/C;EACA;AACJ;AACA;EACII,WAAWA,CAAA,EAAG;IAAE,OAAO,IAAIC,WAAW,CAAC,IAAI,CAACC,MAAM,CAAC;EAAE;EACrD;AACJ;AACA;EACI,OAAOd,KAAKA,CAACN,IAAI,EAAE;IACf,IAAIqB,MAAM,GAAGrB,IAAI,CAACqB,MAAM;IACxB,IAAIA,MAAM,CAACC,WAAW,IAAI,CAACC,YAAY,CAACvB,IAAI,CAAC,IAAI,CAACwB,WAAW,CAACxB,IAAI,CAAC,EAC/D,OAAO,KAAK;IAChB,IAAIyB,QAAQ,GAAGJ,MAAM,CAACR,IAAI,CAACa,IAAI,CAACC,cAAc;IAC9C,IAAIF,QAAQ,IAAI,IAAI,EAChB,OAAOA,QAAQ;IACnB,IAAIG,KAAK,GAAGP,MAAM,CAACQ,cAAc,CAAC7B,IAAI,CAAC8B,KAAK,CAAC,CAAC,CAAC,CAACC,WAAW;IAC3D,OAAOH,KAAK,IAAIA,KAAK,CAACN,WAAW;EACrC;EACA;AACJ;AACA;EACI,OAAOU,iBAAiBA,CAAChC,IAAI,EAAEiC,GAAG,EAAoB;IAAA,IAAlBC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;IAChDG,MAAM,EAAE,SAAS;MACb,IAAI,CAACJ,QAAQ,IAAIpC,SAAS,CAACQ,KAAK,CAACN,IAAI,CAAC,EAClC,OAAOA,IAAI;MACf,IAAIc,GAAG,GAAGd,IAAI,CAACc,GAAG;QAAEyB,IAAI,GAAG,IAAI;MAC/B;MACA,KAAK,IAAIC,CAAC,GAAGxC,IAAI,CAACyC,KAAK,GAAGD,CAAC,EAAE,EAAE;QAC3B,IAAInB,MAAM,GAAGrB,IAAI,CAAC0C,IAAI,CAACF,CAAC,CAAC;QACzB,IAAIP,GAAG,GAAG,CAAC,GAAGjC,IAAI,CAAC2C,UAAU,CAACH,CAAC,CAAC,GAAGnB,MAAM,CAACuB,UAAU,GAAG5C,IAAI,CAAC8B,KAAK,CAACU,CAAC,CAAC,GAAG,CAAC,EAAE;UACtED,IAAI,GAAGlB,MAAM,CAACwB,KAAK,CAACZ,GAAG,GAAG,CAAC,GAAGjC,IAAI,CAAC2C,UAAU,CAACH,CAAC,CAAC,GAAGxC,IAAI,CAAC8B,KAAK,CAACU,CAAC,CAAC,GAAG,CAAC,CAAC;UACrE;QACJ,CAAC,MACI,IAAIA,CAAC,IAAI,CAAC,EAAE;UACb,OAAO,IAAI;QACf;QACA1B,GAAG,IAAImB,GAAG;QACV,IAAIa,IAAI,GAAG9C,IAAI,CAACE,GAAG,CAACE,OAAO,CAACU,GAAG,CAAC;QAChC,IAAIhB,SAAS,CAACQ,KAAK,CAACwC,IAAI,CAAC,EACrB,OAAOA,IAAI;MACnB;MACA;MACA,SAAS;QACL,IAAIC,MAAM,GAAGd,GAAG,GAAG,CAAC,GAAGM,IAAI,CAACS,UAAU,GAAGT,IAAI,CAACU,SAAS;QACvD,IAAI,CAACF,MAAM,EAAE;UACT,IAAIR,IAAI,CAACW,MAAM,IAAI,CAACX,IAAI,CAACY,MAAM,IAAI,CAAC5D,aAAa,CAAC6D,YAAY,CAACb,IAAI,CAAC,EAAE;YAClEvC,IAAI,GAAGA,IAAI,CAACE,GAAG,CAACE,OAAO,CAACU,GAAG,GAAGyB,IAAI,CAACc,QAAQ,GAAGpB,GAAG,CAAC;YAClDC,QAAQ,GAAG,KAAK;YAChB,SAASI,MAAM;UACnB;UACA;QACJ;QACAC,IAAI,GAAGQ,MAAM;QACbjC,GAAG,IAAImB,GAAG;QACV,IAAIa,IAAI,GAAG9C,IAAI,CAACE,GAAG,CAACE,OAAO,CAACU,GAAG,CAAC;QAChC,IAAIhB,SAAS,CAACQ,KAAK,CAACwC,IAAI,CAAC,EACrB,OAAOA,IAAI;MACnB;MACA,OAAO,IAAI;IACf;EACJ;AACJ;AACAhD,SAAS,CAACwD,SAAS,CAACC,OAAO,GAAG,KAAK;AACnCzD,SAAS,CAAC0D,QAAQ,GAAG1D,SAAS,CAACkC,iBAAiB;AAChD1C,SAAS,CAACmE,MAAM,CAAC,WAAW,EAAE3D,SAAS,CAAC;AACxC,MAAMqB,WAAW,CAAC;EACdpB,WAAWA,CAACe,GAAG,EAAE;IACb,IAAI,CAACA,GAAG,GAAGA,GAAG;EAClB;EACAb,GAAGA,CAACE,OAAO,EAAE;IACT,OAAO,IAAIgB,WAAW,CAAChB,OAAO,CAACF,GAAG,CAAC,IAAI,CAACa,GAAG,CAAC,CAAC;EACjD;EACAV,OAAOA,CAACF,GAAG,EAAE;IACT,IAAIF,IAAI,GAAGE,GAAG,CAACE,OAAO,CAAC,IAAI,CAACU,GAAG,CAAC;IAChC,OAAOhB,SAAS,CAACQ,KAAK,CAACN,IAAI,CAAC,GAAG,IAAIF,SAAS,CAACE,IAAI,CAAC,GAAGV,SAAS,CAACiB,IAAI,CAACP,IAAI,CAAC;EAC7E;AACJ;AACA,SAASuB,YAAYA,CAACvB,IAAI,EAAE;EACxB,KAAK,IAAIwC,CAAC,GAAGxC,IAAI,CAACyC,KAAK,EAAED,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAClC,IAAIV,KAAK,GAAG9B,IAAI,CAAC8B,KAAK,CAACU,CAAC,CAAC;MAAEnB,MAAM,GAAGrB,IAAI,CAAC0C,IAAI,CAACF,CAAC,CAAC;IAChD;IACA,IAAIV,KAAK,IAAI,CAAC,EAAE;MACZ,IAAIT,MAAM,CAACR,IAAI,CAACa,IAAI,CAACgC,SAAS,EAC1B,OAAO,IAAI;MACf;IACJ;IACA;IACA,KAAK,IAAIC,MAAM,GAAGtC,MAAM,CAACwB,KAAK,CAACf,KAAK,GAAG,CAAC,CAAC,GAAG6B,MAAM,GAAGA,MAAM,CAACV,SAAS,EAAE;MACnE,IAAKU,MAAM,CAACf,UAAU,IAAI,CAAC,IAAI,CAACe,MAAM,CAACC,aAAa,IAAKD,MAAM,CAACT,MAAM,IAAIS,MAAM,CAAC9C,IAAI,CAACa,IAAI,CAACgC,SAAS,EAChG,OAAO,IAAI;MACf,IAAIC,MAAM,CAACC,aAAa,EACpB,OAAO,KAAK;IACpB;EACJ;EACA;EACA,OAAO,IAAI;AACf;AACA,SAASpC,WAAWA,CAACxB,IAAI,EAAE;EACvB,KAAK,IAAIwC,CAAC,GAAGxC,IAAI,CAACyC,KAAK,EAAED,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAClC,IAAIV,KAAK,GAAG9B,IAAI,CAAC2C,UAAU,CAACH,CAAC,CAAC;MAAEnB,MAAM,GAAGrB,IAAI,CAAC0C,IAAI,CAACF,CAAC,CAAC;IACrD,IAAIV,KAAK,IAAIT,MAAM,CAACuB,UAAU,EAAE;MAC5B,IAAIvB,MAAM,CAACR,IAAI,CAACa,IAAI,CAACgC,SAAS,EAC1B,OAAO,IAAI;MACf;IACJ;IACA,KAAK,IAAIG,KAAK,GAAGxC,MAAM,CAACwB,KAAK,CAACf,KAAK,CAAC,GAAG+B,KAAK,GAAGA,KAAK,CAACb,UAAU,EAAE;MAC7D,IAAKa,KAAK,CAACjB,UAAU,IAAI,CAAC,IAAI,CAACiB,KAAK,CAACD,aAAa,IAAKC,KAAK,CAACX,MAAM,IAAIW,KAAK,CAAChD,IAAI,CAACa,IAAI,CAACgC,SAAS,EAC5F,OAAO,IAAI;MACf,IAAIG,KAAK,CAACD,aAAa,EACnB,OAAO,KAAK;IACpB;EACJ;EACA,OAAO,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,SAASA,CAAA,EAAG;EACjB,OAAO,IAAIrE,MAAM,CAAC;IACdsE,KAAK,EAAE;MACHC,WAAW,EAAEC,aAAa;MAC1BC,sBAAsBA,CAACC,KAAK,EAAEC,OAAO,EAAEC,KAAK,EAAE;QAC1C,OAAOD,OAAO,CAACtD,GAAG,IAAIuD,KAAK,CAACvD,GAAG,IAAIhB,SAAS,CAACQ,KAAK,CAAC+D,KAAK,CAAC,GAAG,IAAIvE,SAAS,CAACuE,KAAK,CAAC,GAAG,IAAI;MAC3F,CAAC;MACDC,WAAW;MACXC,aAAa;MACbC,eAAe,EAAE;QAAEC,WAAW,EAAEA;MAAY;IAChD;EACJ,CAAC,CAAC;AACN;AACA,MAAMF,aAAa,GAAGlF,cAAc,CAAC;EACjC,WAAW,EAAEqF,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;EAC/B,YAAY,EAAEA,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;EAC/B,SAAS,EAAEA,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;EAC5B,WAAW,EAAEA,KAAK,CAAC,MAAM,EAAE,CAAC;AAChC,CAAC,CAAC;AACF,SAASA,KAAKA,CAACC,IAAI,EAAE1C,GAAG,EAAE;EACtB,MAAM2C,MAAM,GAAGD,IAAI,IAAI,MAAM,GAAI1C,GAAG,GAAG,CAAC,GAAG,MAAM,GAAG,IAAI,GAAKA,GAAG,GAAG,CAAC,GAAG,OAAO,GAAG,MAAO;EACxF,OAAO,UAAU4C,KAAK,EAAEC,QAAQ,EAAEC,IAAI,EAAE;IACpC,IAAIC,GAAG,GAAGH,KAAK,CAACI,SAAS;IACzB,IAAIC,MAAM,GAAGjD,GAAG,GAAG,CAAC,GAAG+C,GAAG,CAACG,GAAG,GAAGH,GAAG,CAACI,KAAK;MAAElD,QAAQ,GAAG8C,GAAG,CAACvE,KAAK;IAChE,IAAIuE,GAAG,YAAYxF,aAAa,EAAE;MAC9B,IAAI,CAACuF,IAAI,CAACM,cAAc,CAACT,MAAM,CAAC,IAAIM,MAAM,CAACzC,KAAK,IAAI,CAAC,EACjD,OAAO,KAAK;MAChBP,QAAQ,GAAG,KAAK;MAChBgD,MAAM,GAAGL,KAAK,CAAC3E,GAAG,CAACE,OAAO,CAAC6B,GAAG,GAAG,CAAC,GAAGiD,MAAM,CAACrB,KAAK,CAAC,CAAC,GAAGqB,MAAM,CAACvB,MAAM,CAAC,CAAC,CAAC;IAC1E;IACA,IAAI2B,MAAM,GAAGxF,SAAS,CAACkC,iBAAiB,CAACkD,MAAM,EAAEjD,GAAG,EAAEC,QAAQ,CAAC;IAC/D,IAAI,CAACoD,MAAM,EACP,OAAO,KAAK;IAChB,IAAIR,QAAQ,EACRA,QAAQ,CAACD,KAAK,CAACU,EAAE,CAACC,YAAY,CAAC,IAAI1F,SAAS,CAACwF,MAAM,CAAC,CAAC,CAAC;IAC1D,OAAO,IAAI;EACf,CAAC;AACL;AACA,SAAShB,WAAWA,CAACS,IAAI,EAAEjE,GAAG,EAAE2E,KAAK,EAAE;EACnC,IAAI,CAACV,IAAI,IAAI,CAACA,IAAI,CAACW,QAAQ,EACvB,OAAO,KAAK;EAChB,IAAI1F,IAAI,GAAG+E,IAAI,CAACF,KAAK,CAAC3E,GAAG,CAACE,OAAO,CAACU,GAAG,CAAC;EACtC,IAAI,CAAChB,SAAS,CAACQ,KAAK,CAACN,IAAI,CAAC,EACtB,OAAO,KAAK;EAChB,IAAI2F,QAAQ,GAAGZ,IAAI,CAACa,WAAW,CAAC;IAAEC,IAAI,EAAEJ,KAAK,CAACK,OAAO;IAAEC,GAAG,EAAEN,KAAK,CAACO;EAAQ,CAAC,CAAC;EAC5E,IAAIL,QAAQ,IAAIA,QAAQ,CAAC5C,MAAM,GAAG,CAAC,CAAC,IAAIxD,aAAa,CAAC6D,YAAY,CAAC2B,IAAI,CAACF,KAAK,CAAC3E,GAAG,CAAC+F,MAAM,CAACN,QAAQ,CAAC5C,MAAM,CAAC,CAAC,EACtG,OAAO,KAAK;EAChBgC,IAAI,CAACD,QAAQ,CAACC,IAAI,CAACF,KAAK,CAACU,EAAE,CAACC,YAAY,CAAC,IAAI1F,SAAS,CAACE,IAAI,CAAC,CAAC,CAAC;EAC9D,OAAO,IAAI;AACf;AACA;AACA;AACA;AACA;AACA,SAASyE,WAAWA,CAACM,IAAI,EAAEU,KAAK,EAAE;EAC9B,IAAIA,KAAK,CAACS,SAAS,IAAI,uBAAuB,IAAI,EAAEnB,IAAI,CAACF,KAAK,CAACI,SAAS,YAAYnF,SAAS,CAAC,EAC1F,OAAO,KAAK;EAChB,IAAI;IAAEsF;EAAM,CAAC,GAAGL,IAAI,CAACF,KAAK,CAACI,SAAS;EACpC,IAAIkB,MAAM,GAAGf,KAAK,CAAC/D,MAAM,CAACQ,cAAc,CAACuD,KAAK,CAACtD,KAAK,CAAC,CAAC,CAAC,CAACsE,YAAY,CAACrB,IAAI,CAACF,KAAK,CAACwB,MAAM,CAACC,KAAK,CAACC,IAAI,CAAC;EAClG,IAAI,CAACJ,MAAM,EACP,OAAO,KAAK;EAChB,IAAIK,IAAI,GAAG7G,QAAQ,CAACc,KAAK;EACzB,KAAK,IAAIgG,CAAC,GAAGN,MAAM,CAAC/D,MAAM,GAAG,CAAC,EAAEqE,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EACvCD,IAAI,GAAG7G,QAAQ,CAAC+G,IAAI,CAACP,MAAM,CAACM,CAAC,CAAC,CAACE,aAAa,CAAC,IAAI,EAAEH,IAAI,CAAC,CAAC;EAC7D,IAAIjB,EAAE,GAAGR,IAAI,CAACF,KAAK,CAACU,EAAE,CAACqB,OAAO,CAACxB,KAAK,CAACtE,GAAG,EAAEsE,KAAK,CAACtE,GAAG,EAAE,IAAIpB,KAAK,CAAC8G,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EAC3EjB,EAAE,CAACC,YAAY,CAAChG,aAAa,CAACe,IAAI,CAACgF,EAAE,CAACrF,GAAG,CAACE,OAAO,CAACgF,KAAK,CAACtE,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;EAClEiE,IAAI,CAACD,QAAQ,CAACS,EAAE,CAAC;EACjB,OAAO,KAAK;AAChB;AACA,SAAStB,aAAaA,CAACY,KAAK,EAAE;EAC1B,IAAI,EAAEA,KAAK,CAACI,SAAS,YAAYnF,SAAS,CAAC,EACvC,OAAO,IAAI;EACf,IAAI4C,IAAI,GAAGmE,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;EACxCpE,IAAI,CAACqE,SAAS,GAAG,uBAAuB;EACxC,OAAOnH,aAAa,CAACoH,MAAM,CAACnC,KAAK,CAAC3E,GAAG,EAAE,CAACL,UAAU,CAACoH,MAAM,CAACpC,KAAK,CAACI,SAAS,CAAC5E,IAAI,EAAEqC,IAAI,EAAE;IAAEwE,GAAG,EAAE;EAAY,CAAC,CAAC,CAAC,CAAC;AACjH;AAEA,SAASpH,SAAS,EAAEgE,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}