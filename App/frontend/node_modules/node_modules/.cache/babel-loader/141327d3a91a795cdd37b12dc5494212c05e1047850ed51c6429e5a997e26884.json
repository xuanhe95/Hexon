{"ast":null,"code":"/*!\n* tiptap-extensions v1.35.1\n* (c) 2021 überdosis GbR (limited liability)\n* @license MIT\n*/\n\nimport { Node, Plugin, PluginKey, Mark, Extension } from 'tiptap';\nimport { toggleWrap, wrappingInputRule, toggleList, toggleBlockType, setBlockType, textblockTypeInputRule, chainCommands, exitCode, nodeInputRule, splitListItem, sinkListItem, liftListItem, insertText, replaceText, splitToDefaultListItem, toggleMark, markInputRule, markPasteRule, updateMark, removeMark, pasteRule } from 'tiptap-commands';\nimport low from 'lowlight/lib/core';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\nimport { findBlockNodes, createTable, getMarkAttrs, nodeEqualsType } from 'tiptap-utils';\nimport { Fragment } from 'prosemirror-model';\nimport { Plugin as Plugin$1, PluginKey as PluginKey$1, TextSelection } from 'prosemirror-state';\nimport { tableNodes, addColumnBefore, addColumnAfter, deleteColumn, addRowBefore, addRowAfter, deleteRow, deleteTable, mergeCells, splitCell, toggleHeaderColumn, toggleHeaderRow, toggleHeaderCell, setCellAttr, fixTables, goToNextCell, columnResizing, tableEditing } from 'prosemirror-tables';\nimport { Step } from 'prosemirror-transform';\nimport { sendableSteps, getVersion, receiveTransaction, collab } from 'prosemirror-collab';\nimport { history, undo, redo, undoDepth, redoDepth } from 'prosemirror-history';\nclass Blockquote extends Node {\n  get name() {\n    return 'blockquote';\n  }\n  get schema() {\n    return {\n      content: 'block*',\n      group: 'block',\n      defining: true,\n      draggable: false,\n      parseDOM: [{\n        tag: 'blockquote'\n      }],\n      toDOM: () => ['blockquote', 0]\n    };\n  }\n  commands(_ref) {\n    let {\n      type\n    } = _ref;\n    return () => toggleWrap(type);\n  }\n  keys(_ref2) {\n    let {\n      type\n    } = _ref2;\n    return {\n      'Ctrl->': toggleWrap(type)\n    };\n  }\n  inputRules(_ref3) {\n    let {\n      type\n    } = _ref3;\n    return [wrappingInputRule(/^\\s*>\\s$/, type)];\n  }\n}\nclass BulletList extends Node {\n  get name() {\n    return 'bullet_list';\n  }\n  get schema() {\n    return {\n      content: 'list_item+',\n      group: 'block',\n      parseDOM: [{\n        tag: 'ul'\n      }],\n      toDOM: () => ['ul', 0]\n    };\n  }\n  commands(_ref4) {\n    let {\n      type,\n      schema\n    } = _ref4;\n    return () => toggleList(type, schema.nodes.list_item);\n  }\n  keys(_ref5) {\n    let {\n      type,\n      schema\n    } = _ref5;\n    return {\n      'Shift-Ctrl-8': toggleList(type, schema.nodes.list_item)\n    };\n  }\n  inputRules(_ref6) {\n    let {\n      type\n    } = _ref6;\n    return [wrappingInputRule(/^\\s*([-+*])\\s$/, type)];\n  }\n}\nclass CodeBlock extends Node {\n  get name() {\n    return 'code_block';\n  }\n  get schema() {\n    return {\n      content: 'text*',\n      marks: '',\n      group: 'block',\n      code: true,\n      defining: true,\n      draggable: false,\n      parseDOM: [{\n        tag: 'pre',\n        preserveWhitespace: 'full'\n      }],\n      toDOM: () => ['pre', ['code', 0]]\n    };\n  }\n  commands(_ref7) {\n    let {\n      type,\n      schema\n    } = _ref7;\n    return () => toggleBlockType(type, schema.nodes.paragraph);\n  }\n  keys(_ref8) {\n    let {\n      type\n    } = _ref8;\n    return {\n      'Shift-Ctrl-\\\\': setBlockType(type)\n    };\n  }\n  inputRules(_ref9) {\n    let {\n      type\n    } = _ref9;\n    return [textblockTypeInputRule(/^```$/, type)];\n  }\n}\nfunction getDecorations(_ref10) {\n  let {\n    doc,\n    name\n  } = _ref10;\n  const decorations = [];\n  const blocks = findBlockNodes(doc).filter(item => item.node.type.name === name);\n  const flatten = list => list.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);\n  function parseNodes(nodes) {\n    let className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return nodes.map(node => {\n      const classes = [...className, ...(node.properties ? node.properties.className : [])];\n      if (node.children) {\n        return parseNodes(node.children, classes);\n      }\n      return {\n        text: node.value,\n        classes\n      };\n    });\n  }\n  blocks.forEach(block => {\n    let startPos = block.pos + 1;\n    const nodes = low.highlightAuto(block.node.textContent).value;\n    flatten(parseNodes(nodes)).map(node => {\n      const from = startPos;\n      const to = from + node.text.length;\n      startPos = to;\n      return {\n        ...node,\n        from,\n        to\n      };\n    }).forEach(node => {\n      const decoration = Decoration.inline(node.from, node.to, {\n        class: node.classes.join(' ')\n      });\n      decorations.push(decoration);\n    });\n  });\n  return DecorationSet.create(doc, decorations);\n}\nfunction HighlightPlugin(_ref11) {\n  let {\n    name\n  } = _ref11;\n  return new Plugin({\n    name: new PluginKey('highlight'),\n    state: {\n      init: (_, _ref12) => {\n        let {\n          doc\n        } = _ref12;\n        return getDecorations({\n          doc,\n          name\n        });\n      },\n      apply: (transaction, decorationSet, oldState, newState) => {\n        // TODO: find way to cache decorations\n        // https://discuss.prosemirror.net/t/how-to-update-multiple-inline-decorations-on-node-change/1493\n        const oldNodeName = oldState.selection.$head.parent.type.name;\n        const newNodeName = newState.selection.$head.parent.type.name;\n        const oldNodes = findBlockNodes(oldState.doc).filter(item => item.node.type.name === name);\n        const newNodes = findBlockNodes(newState.doc).filter(item => item.node.type.name === name); // Apply decorations if selection includes named node, or transaction changes named node.\n\n        if (transaction.docChanged && ([oldNodeName, newNodeName].includes(name) || newNodes.length !== oldNodes.length)) {\n          return getDecorations({\n            doc: transaction.doc,\n            name\n          });\n        }\n        return decorationSet.map(transaction.mapping, transaction.doc);\n      }\n    },\n    props: {\n      decorations(state) {\n        return this.getState(state);\n      }\n    }\n  });\n}\nclass CodeBlockHighlight extends Node {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    try {\n      Object.entries(this.options.languages).forEach(_ref13 => {\n        let [name, mapping] = _ref13;\n        low.registerLanguage(name, mapping);\n      });\n    } catch (err) {\n      throw new Error('Invalid syntax highlight definitions: define at least one highlight.js language mapping');\n    }\n  }\n  get name() {\n    return 'code_block';\n  }\n  get defaultOptions() {\n    return {\n      languages: {}\n    };\n  }\n  get schema() {\n    return {\n      content: 'text*',\n      marks: '',\n      group: 'block',\n      code: true,\n      defining: true,\n      draggable: false,\n      parseDOM: [{\n        tag: 'pre',\n        preserveWhitespace: 'full'\n      }],\n      toDOM: () => ['pre', ['code', 0]]\n    };\n  }\n  commands(_ref14) {\n    let {\n      type,\n      schema\n    } = _ref14;\n    return () => toggleBlockType(type, schema.nodes.paragraph);\n  }\n  keys(_ref15) {\n    let {\n      type\n    } = _ref15;\n    return {\n      'Shift-Ctrl-\\\\': setBlockType(type)\n    };\n  }\n  inputRules(_ref16) {\n    let {\n      type\n    } = _ref16;\n    return [textblockTypeInputRule(/^```$/, type)];\n  }\n  get plugins() {\n    return [HighlightPlugin({\n      name: this.name\n    })];\n  }\n}\nclass HardBreak extends Node {\n  get name() {\n    return 'hard_break';\n  }\n  get schema() {\n    return {\n      inline: true,\n      group: 'inline',\n      selectable: false,\n      parseDOM: [{\n        tag: 'br'\n      }],\n      toDOM: () => ['br']\n    };\n  }\n  commands(_ref17) {\n    let {\n      type\n    } = _ref17;\n    return () => chainCommands(exitCode, (state, dispatch) => {\n      dispatch(state.tr.replaceSelectionWith(type.create()).scrollIntoView());\n      return true;\n    });\n  }\n  keys(_ref18) {\n    let {\n      type\n    } = _ref18;\n    const command = chainCommands(exitCode, (state, dispatch) => {\n      dispatch(state.tr.replaceSelectionWith(type.create()).scrollIntoView());\n      return true;\n    });\n    return {\n      'Mod-Enter': command,\n      'Shift-Enter': command\n    };\n  }\n}\nclass Heading extends Node {\n  get name() {\n    return 'heading';\n  }\n  get defaultOptions() {\n    return {\n      levels: [1, 2, 3, 4, 5, 6]\n    };\n  }\n  get schema() {\n    return {\n      attrs: {\n        level: {\n          default: 1\n        }\n      },\n      content: 'inline*',\n      group: 'block',\n      defining: true,\n      draggable: false,\n      parseDOM: this.options.levels.map(level => ({\n        tag: `h${level}`,\n        attrs: {\n          level\n        }\n      })),\n      toDOM: node => [`h${node.attrs.level}`, 0]\n    };\n  }\n  commands(_ref19) {\n    let {\n      type,\n      schema\n    } = _ref19;\n    return attrs => toggleBlockType(type, schema.nodes.paragraph, attrs);\n  }\n  keys(_ref20) {\n    let {\n      type\n    } = _ref20;\n    return this.options.levels.reduce((items, level) => ({\n      ...items,\n      ...{\n        [`Shift-Ctrl-${level}`]: setBlockType(type, {\n          level\n        })\n      }\n    }), {});\n  }\n  inputRules(_ref21) {\n    let {\n      type\n    } = _ref21;\n    return this.options.levels.map(level => textblockTypeInputRule(new RegExp(`^(#{1,${level}})\\\\s$`), type, () => ({\n      level\n    })));\n  }\n}\nclass HorizontalRule extends Node {\n  get name() {\n    return 'horizontal_rule';\n  }\n  get schema() {\n    return {\n      group: 'block',\n      parseDOM: [{\n        tag: 'hr'\n      }],\n      toDOM: () => ['hr']\n    };\n  }\n  commands(_ref22) {\n    let {\n      type\n    } = _ref22;\n    return () => (state, dispatch) => dispatch(state.tr.replaceSelectionWith(type.create()));\n  }\n  inputRules(_ref23) {\n    let {\n      type\n    } = _ref23;\n    return [nodeInputRule(/^(?:---|___\\s|\\*\\*\\*\\s)$/, type)];\n  }\n}\n\n/**\n * Matches following attributes in Markdown-typed image: [, alt, src, title]\n *\n * Example:\n * ![Lorem](image.jpg) -> [, \"Lorem\", \"image.jpg\"]\n * ![](image.jpg \"Ipsum\") -> [, \"\", \"image.jpg\", \"Ipsum\"]\n * ![Lorem](image.jpg \"Ipsum\") -> [, \"Lorem\", \"image.jpg\", \"Ipsum\"]\n */\n\nconst IMAGE_INPUT_REGEX = /!\\[(.+|:?)]\\((\\S+)(?:(?:\\s+)[\"'](\\S+)[\"'])?\\)/;\nclass Image extends Node {\n  get name() {\n    return 'image';\n  }\n  get schema() {\n    return {\n      inline: true,\n      attrs: {\n        src: {},\n        alt: {\n          default: null\n        },\n        title: {\n          default: null\n        }\n      },\n      group: 'inline',\n      draggable: true,\n      parseDOM: [{\n        tag: 'img[src]',\n        getAttrs: dom => ({\n          src: dom.getAttribute('src'),\n          title: dom.getAttribute('title'),\n          alt: dom.getAttribute('alt')\n        })\n      }],\n      toDOM: node => ['img', node.attrs]\n    };\n  }\n  commands(_ref24) {\n    let {\n      type\n    } = _ref24;\n    return attrs => (state, dispatch) => {\n      const {\n        selection\n      } = state;\n      const position = selection.$cursor ? selection.$cursor.pos : selection.$to.pos;\n      const node = type.create(attrs);\n      const transaction = state.tr.insert(position, node);\n      dispatch(transaction);\n    };\n  }\n  inputRules(_ref25) {\n    let {\n      type\n    } = _ref25;\n    return [nodeInputRule(IMAGE_INPUT_REGEX, type, match => {\n      const [, alt, src, title] = match;\n      return {\n        src,\n        alt,\n        title\n      };\n    })];\n  }\n  get plugins() {\n    return [new Plugin({\n      props: {\n        handleDOMEvents: {\n          drop(view, event) {\n            const hasFiles = event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length;\n            if (!hasFiles) {\n              return;\n            }\n            const images = Array.from(event.dataTransfer.files).filter(file => /image/i.test(file.type));\n            if (images.length === 0) {\n              return;\n            }\n            event.preventDefault();\n            const {\n              schema\n            } = view.state;\n            const coordinates = view.posAtCoords({\n              left: event.clientX,\n              top: event.clientY\n            });\n            images.forEach(image => {\n              const reader = new FileReader();\n              reader.onload = readerEvent => {\n                const node = schema.nodes.image.create({\n                  src: readerEvent.target.result\n                });\n                const transaction = view.state.tr.insert(coordinates.pos, node);\n                view.dispatch(transaction);\n              };\n              reader.readAsDataURL(image);\n            });\n          }\n        }\n      }\n    })];\n  }\n}\nclass ListItem extends Node {\n  get name() {\n    return 'list_item';\n  }\n  get schema() {\n    return {\n      content: 'paragraph block*',\n      defining: true,\n      draggable: false,\n      parseDOM: [{\n        tag: 'li'\n      }],\n      toDOM: () => ['li', 0]\n    };\n  }\n  keys(_ref26) {\n    let {\n      type\n    } = _ref26;\n    return {\n      Enter: splitListItem(type),\n      Tab: sinkListItem(type),\n      'Shift-Tab': liftListItem(type)\n    };\n  }\n}\nfunction getTextBetween(node, from, to, blockSeparator, inlineSeparator) {\n  let leafText = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '\\0';\n  let text = '';\n  let blockSeparated = true;\n  let inlineNode = null;\n  node.content.nodesBetween(from, to, (innerNode, pos) => {\n    if (innerNode.isText) {\n      if (inlineNode) {\n        inlineNode = null;\n        return;\n      }\n      text += innerNode.text.slice(Math.max(from, pos) - pos, to - pos);\n      blockSeparated = !blockSeparator;\n    } else if (innerNode.isLeaf && leafText) {\n      text += leafText;\n      blockSeparated = !blockSeparator;\n    } else if (innerNode.isInline && !innerNode.isLeaf) {\n      text += inlineSeparator;\n      if (innerNode.textContent) {\n        text += innerNode.textContent;\n        inlineNode = innerNode;\n      }\n      text += inlineSeparator;\n      blockSeparated = !blockSeparated;\n    } else if (!blockSeparated && innerNode.isBlock) {\n      text += blockSeparator;\n      blockSeparated = true;\n    }\n  }, 0);\n  return text;\n} // Create a matcher that matches when a specific character is typed. Useful for @mentions and #tags.\n\nfunction triggerCharacter(_ref27) {\n  let {\n    char = '@',\n    allowSpaces = false,\n    startOfLine = false\n  } = _ref27;\n  return $position => {\n    // cancel if top level node\n    if ($position.depth <= 0) {\n      return false;\n    } // Matching expressions used for later\n\n    const escapedChar = `\\\\${char}`;\n    const suffix = new RegExp(`\\\\s${escapedChar}$`);\n    const prefix = startOfLine ? '^' : '';\n    const regexp = allowSpaces ? new RegExp(`${prefix}${escapedChar}.*?(?=\\\\s${escapedChar}|$)`, 'gm') : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\\\s${escapedChar}]*`, 'gm'); // Lookup the boundaries of the current node\n\n    const textFrom = $position.before();\n    const textTo = $position.end();\n    const text = getTextBetween($position.doc, textFrom, textTo, '\\0', '\\0');\n    let match = regexp.exec(text);\n    let position;\n    while (match !== null) {\n      // JavaScript doesn't have lookbehinds; this hacks a check that first character is \" \"\n      // or the line beginning\n      const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);\n      if (/^[\\s\\0]?$/.test(matchPrefix)) {\n        // The absolute position of the match in the document\n        const from = match.index + $position.start();\n        let to = from + match[0].length; // Edge case handling; if spaces are allowed and we're directly in between\n        // two triggers\n\n        if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\n          match[0] += ' ';\n          to += 1;\n        } // If the $position is located within the matched substring, return that range\n\n        if (from < $position.pos && to >= $position.pos) {\n          position = {\n            range: {\n              from,\n              to\n            },\n            query: match[0].slice(char.length),\n            text: match[0]\n          };\n        }\n      }\n      match = regexp.exec(text);\n    }\n    return position;\n  };\n}\nfunction SuggestionsPlugin(_ref28) {\n  let {\n    matcher = {\n      char: '@',\n      allowSpaces: false,\n      startOfLine: false\n    },\n    appendText = null,\n    suggestionClass = 'suggestion',\n    command = () => false,\n    items = [],\n    onEnter = () => false,\n    onChange = () => false,\n    onExit = () => false,\n    onKeyDown = () => false,\n    onFilter = (searchItems, query) => {\n      if (!query) {\n        return searchItems;\n      }\n      return searchItems.filter(item => JSON.stringify(item).toLowerCase().includes(query.toLowerCase()));\n    }\n  } = _ref28;\n  return new Plugin$1({\n    key: new PluginKey$1('suggestions'),\n    view() {\n      return {\n        update: async (view, prevState) => {\n          const prev = this.key.getState(prevState);\n          const next = this.key.getState(view.state); // See how the state changed\n\n          const moved = prev.active && next.active && prev.range.from !== next.range.from;\n          const started = !prev.active && next.active;\n          const stopped = prev.active && !next.active;\n          const changed = !started && !stopped && prev.query !== next.query;\n          const handleStart = started || moved;\n          const handleChange = changed && !moved;\n          const handleExit = stopped || moved; // Cancel when suggestion isn't active\n\n          if (!handleStart && !handleChange && !handleExit) {\n            return;\n          }\n          const state = handleExit ? prev : next;\n          const decorationNode = document.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`); // build a virtual node for popper.js or tippy.js\n          // this can be used for building popups without a DOM node\n\n          const virtualNode = decorationNode ? {\n            getBoundingClientRect() {\n              return decorationNode.getBoundingClientRect();\n            },\n            clientWidth: decorationNode.clientWidth,\n            clientHeight: decorationNode.clientHeight\n          } : null;\n          const props = {\n            view,\n            range: state.range,\n            query: state.query,\n            text: state.text,\n            decorationNode,\n            virtualNode,\n            items: handleChange || handleStart ? await onFilter(Array.isArray(items) ? items : await items(), state.query) : [],\n            command: _ref29 => {\n              let {\n                range,\n                attrs\n              } = _ref29;\n              command({\n                range,\n                attrs,\n                schema: view.state.schema\n              })(view.state, view.dispatch, view);\n              if (appendText) {\n                insertText(appendText)(view.state, view.dispatch, view);\n              }\n            }\n          }; // Trigger the hooks when necessary\n\n          if (handleExit) {\n            onExit(props);\n          }\n          if (handleChange) {\n            onChange(props);\n          }\n          if (handleStart) {\n            onEnter(props);\n          }\n        }\n      };\n    },\n    state: {\n      // Initialize the plugin's internal state.\n      init() {\n        return {\n          active: false,\n          range: {},\n          query: null,\n          text: null\n        };\n      },\n      // Apply changes to the plugin state from a view transaction.\n      apply(tr, prev) {\n        const {\n          selection\n        } = tr;\n        const next = {\n          ...prev\n        }; // We can only be suggesting if there is no selection\n\n        if (selection.from === selection.to) {\n          // Reset active state if we just left the previous suggestion range\n          if (selection.from < prev.range.from || selection.from > prev.range.to) {\n            next.active = false;\n          } // Try to match against where our cursor currently is\n\n          const $position = selection.$from;\n          const match = triggerCharacter(matcher)($position);\n          const decorationId = (Math.random() + 1).toString(36).substr(2, 5); // If we found a match, update the current state to show it\n\n          if (match) {\n            next.active = true;\n            next.decorationId = prev.decorationId ? prev.decorationId : decorationId;\n            next.range = match.range;\n            next.query = match.query;\n            next.text = match.text;\n          } else {\n            next.active = false;\n          }\n        } else {\n          next.active = false;\n        } // Make sure to empty the range if suggestion is inactive\n\n        if (!next.active) {\n          next.decorationId = null;\n          next.range = {};\n          next.query = null;\n          next.text = null;\n        }\n        return next;\n      }\n    },\n    props: {\n      // Call the keydown hook if suggestion is active.\n      handleKeyDown(view, event) {\n        const {\n          active,\n          range\n        } = this.getState(view.state);\n        if (!active) return false;\n        return onKeyDown({\n          view,\n          event,\n          range\n        });\n      },\n      // Setup decorator on the currently active suggestion.\n      decorations(editorState) {\n        const {\n          active,\n          range,\n          decorationId\n        } = this.getState(editorState);\n        if (!active) return null;\n        return DecorationSet.create(editorState.doc, [Decoration.inline(range.from, range.to, {\n          nodeName: 'span',\n          class: suggestionClass,\n          'data-decoration-id': decorationId\n        })]);\n      }\n    }\n  });\n}\nclass Mention extends Node {\n  get name() {\n    return 'mention';\n  }\n  get defaultOptions() {\n    return {\n      matcher: {\n        char: '@',\n        allowSpaces: false,\n        startOfLine: false\n      },\n      mentionClass: 'mention',\n      suggestionClass: 'mention-suggestion'\n    };\n  }\n  getLabel(dom) {\n    return dom.innerText.split(this.options.matcher.char).join('');\n  }\n  createFragment(schema, label) {\n    return Fragment.fromJSON(schema, [{\n      type: 'text',\n      text: `${this.options.matcher.char}${label}`\n    }]);\n  }\n  insertMention(range, attrs, schema) {\n    const nodeType = schema.nodes[this.name];\n    const nodeFragment = this.createFragment(schema, attrs.label);\n    return replaceText(range, nodeType, attrs, nodeFragment);\n  }\n  get schema() {\n    return {\n      attrs: {\n        id: {},\n        label: {}\n      },\n      group: 'inline',\n      inline: true,\n      content: 'text*',\n      selectable: false,\n      atom: true,\n      toDOM: node => ['span', {\n        class: this.options.mentionClass,\n        'data-mention-id': node.attrs.id\n      }, `${this.options.matcher.char}${node.attrs.label}`],\n      parseDOM: [{\n        tag: 'span[data-mention-id]',\n        getAttrs: dom => {\n          const id = dom.getAttribute('data-mention-id');\n          const label = this.getLabel(dom);\n          return {\n            id,\n            label\n          };\n        },\n        getContent: (dom, schema) => {\n          const label = this.getLabel(dom);\n          return this.createFragment(schema, label);\n        }\n      }]\n    };\n  }\n  commands(_ref30) {\n    let {\n      schema\n    } = _ref30;\n    return attrs => this.insertMention(null, attrs, schema);\n  }\n  get plugins() {\n    return [SuggestionsPlugin({\n      command: _ref31 => {\n        let {\n          range,\n          attrs,\n          schema\n        } = _ref31;\n        return this.insertMention(range, attrs, schema);\n      },\n      appendText: ' ',\n      matcher: this.options.matcher,\n      items: this.options.items,\n      onEnter: this.options.onEnter,\n      onChange: this.options.onChange,\n      onExit: this.options.onExit,\n      onKeyDown: this.options.onKeyDown,\n      onFilter: this.options.onFilter,\n      suggestionClass: this.options.suggestionClass\n    })];\n  }\n}\nclass OrderedList extends Node {\n  get name() {\n    return 'ordered_list';\n  }\n  get schema() {\n    return {\n      attrs: {\n        order: {\n          default: 1\n        }\n      },\n      content: 'list_item+',\n      group: 'block',\n      parseDOM: [{\n        tag: 'ol',\n        getAttrs: dom => ({\n          order: dom.hasAttribute('start') ? +dom.getAttribute('start') : 1\n        })\n      }],\n      toDOM: node => node.attrs.order === 1 ? ['ol', 0] : ['ol', {\n        start: node.attrs.order\n      }, 0]\n    };\n  }\n  commands(_ref32) {\n    let {\n      type,\n      schema\n    } = _ref32;\n    return () => toggleList(type, schema.nodes.list_item);\n  }\n  keys(_ref33) {\n    let {\n      type,\n      schema\n    } = _ref33;\n    return {\n      'Shift-Ctrl-9': toggleList(type, schema.nodes.list_item)\n    };\n  }\n  inputRules(_ref34) {\n    let {\n      type\n    } = _ref34;\n    return [wrappingInputRule(/^(\\d+)\\.\\s$/, type, match => ({\n      order: +match[1]\n    }), (match, node) => node.childCount + node.attrs.order === +match[1])];\n  }\n}\nvar TableNodes = tableNodes({\n  tableGroup: 'block',\n  cellContent: 'block+',\n  cellAttributes: {\n    background: {\n      default: null,\n      getFromDOM(dom) {\n        return dom.style.backgroundColor || null;\n      },\n      setDOMAttr(value, attrs) {\n        if (value) {\n          const style = {\n            style: `${attrs.style || ''}background-color: ${value};`\n          };\n          Object.assign(attrs, style);\n        }\n      }\n    }\n  }\n});\nclass Table extends Node {\n  get name() {\n    return 'table';\n  }\n  get defaultOptions() {\n    return {\n      resizable: false\n    };\n  }\n  get schema() {\n    return TableNodes.table;\n  }\n  commands(_ref35) {\n    let {\n      schema\n    } = _ref35;\n    return {\n      createTable: _ref36 => {\n        let {\n          rowsCount,\n          colsCount,\n          withHeaderRow\n        } = _ref36;\n        return (state, dispatch) => {\n          const offset = state.tr.selection.anchor + 1;\n          const nodes = createTable(schema, rowsCount, colsCount, withHeaderRow);\n          const tr = state.tr.replaceSelectionWith(nodes).scrollIntoView();\n          const resolvedPos = tr.doc.resolve(offset);\n          tr.setSelection(TextSelection.near(resolvedPos));\n          dispatch(tr);\n        };\n      },\n      addColumnBefore: () => addColumnBefore,\n      addColumnAfter: () => addColumnAfter,\n      deleteColumn: () => deleteColumn,\n      addRowBefore: () => addRowBefore,\n      addRowAfter: () => addRowAfter,\n      deleteRow: () => deleteRow,\n      deleteTable: () => deleteTable,\n      toggleCellMerge: () => (state, dispatch) => {\n        if (mergeCells(state, dispatch)) {\n          return;\n        }\n        splitCell(state, dispatch);\n      },\n      mergeCells: () => mergeCells,\n      splitCell: () => splitCell,\n      toggleHeaderColumn: () => toggleHeaderColumn,\n      toggleHeaderRow: () => toggleHeaderRow,\n      toggleHeaderCell: () => toggleHeaderCell,\n      setCellAttr: _ref37 => {\n        let {\n          name,\n          value\n        } = _ref37;\n        return setCellAttr(name, value);\n      },\n      fixTables: () => fixTables\n    };\n  }\n  keys() {\n    return {\n      Tab: goToNextCell(1),\n      'Shift-Tab': goToNextCell(-1)\n    };\n  }\n  get plugins() {\n    return [...(this.options.resizable ? [columnResizing()] : []), tableEditing()];\n  }\n}\nclass TableHeader extends Node {\n  get name() {\n    return 'table_header';\n  }\n  get schema() {\n    return TableNodes.table_header;\n  }\n}\nclass TableCell extends Node {\n  get name() {\n    return 'table_cell';\n  }\n  get schema() {\n    return TableNodes.table_cell;\n  }\n}\nclass TableRow extends Node {\n  get name() {\n    return 'table_row';\n  }\n  get schema() {\n    return TableNodes.table_row;\n  }\n}\nclass TodoItem extends Node {\n  get name() {\n    return 'todo_item';\n  }\n  get defaultOptions() {\n    return {\n      nested: false\n    };\n  }\n  get view() {\n    return {\n      props: ['node', 'updateAttrs', 'view'],\n      methods: {\n        onChange() {\n          this.updateAttrs({\n            done: !this.node.attrs.done\n          });\n        }\n      },\n      template: `\n        <li :data-type=\"node.type.name\" :data-done=\"node.attrs.done.toString()\" data-drag-handle>\n          <span class=\"todo-checkbox\" contenteditable=\"false\" @click=\"onChange\"></span>\n          <div class=\"todo-content\" ref=\"content\" :contenteditable=\"view.editable.toString()\"></div>\n        </li>\n      `\n    };\n  }\n  get schema() {\n    return {\n      attrs: {\n        done: {\n          default: false\n        }\n      },\n      draggable: true,\n      content: this.options.nested ? '(paragraph|todo_list)+' : 'paragraph+',\n      toDOM: node => {\n        const {\n          done\n        } = node.attrs;\n        return ['li', {\n          'data-type': this.name,\n          'data-done': done.toString()\n        }, ['span', {\n          class: 'todo-checkbox',\n          contenteditable: 'false'\n        }], ['div', {\n          class: 'todo-content'\n        }, 0]];\n      },\n      parseDOM: [{\n        priority: 51,\n        tag: `[data-type=\"${this.name}\"]`,\n        getAttrs: dom => ({\n          done: dom.getAttribute('data-done') === 'true'\n        })\n      }]\n    };\n  }\n  keys(_ref38) {\n    let {\n      type\n    } = _ref38;\n    return {\n      Enter: splitToDefaultListItem(type),\n      Tab: this.options.nested ? sinkListItem(type) : () => {},\n      'Shift-Tab': liftListItem(type)\n    };\n  }\n}\nclass TodoList extends Node {\n  get name() {\n    return 'todo_list';\n  }\n  get schema() {\n    return {\n      group: 'block',\n      content: 'todo_item+',\n      toDOM: () => ['ul', {\n        'data-type': this.name\n      }, 0],\n      parseDOM: [{\n        priority: 51,\n        tag: `[data-type=\"${this.name}\"]`\n      }]\n    };\n  }\n  commands(_ref39) {\n    let {\n      type,\n      schema\n    } = _ref39;\n    return () => toggleList(type, schema.nodes.todo_item);\n  }\n  inputRules(_ref40) {\n    let {\n      type\n    } = _ref40;\n    return [wrappingInputRule(/^\\s*(\\[ \\])\\s$/, type)];\n  }\n}\nclass Bold extends Mark {\n  get name() {\n    return 'bold';\n  }\n  get schema() {\n    return {\n      parseDOM: [{\n        tag: 'strong'\n      }, {\n        tag: 'b',\n        getAttrs: node => node.style.fontWeight !== 'normal' && null\n      }, {\n        style: 'font-weight',\n        getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null\n      }],\n      toDOM: () => ['strong', 0]\n    };\n  }\n  keys(_ref41) {\n    let {\n      type\n    } = _ref41;\n    return {\n      'Mod-b': toggleMark(type)\n    };\n  }\n  commands(_ref42) {\n    let {\n      type\n    } = _ref42;\n    return () => toggleMark(type);\n  }\n  inputRules(_ref43) {\n    let {\n      type\n    } = _ref43;\n    return [markInputRule(/(?:\\*\\*|__)([^*_]+)(?:\\*\\*|__)$/, type)];\n  }\n  pasteRules(_ref44) {\n    let {\n      type\n    } = _ref44;\n    return [markPasteRule(/(?:\\*\\*|__)([^*_]+)(?:\\*\\*|__)/g, type)];\n  }\n}\nclass Code extends Mark {\n  get name() {\n    return 'code';\n  }\n  get schema() {\n    return {\n      excludes: '_',\n      parseDOM: [{\n        tag: 'code'\n      }],\n      toDOM: () => ['code', 0]\n    };\n  }\n  keys(_ref45) {\n    let {\n      type\n    } = _ref45;\n    return {\n      'Mod-`': toggleMark(type)\n    };\n  }\n  commands(_ref46) {\n    let {\n      type\n    } = _ref46;\n    return () => toggleMark(type);\n  }\n  inputRules(_ref47) {\n    let {\n      type\n    } = _ref47;\n    return [markInputRule(/(?:`)([^`]+)(?:`)$/, type)];\n  }\n  pasteRules(_ref48) {\n    let {\n      type\n    } = _ref48;\n    return [markPasteRule(/(?:`)([^`]+)(?:`)/g, type)];\n  }\n}\nclass Italic extends Mark {\n  get name() {\n    return 'italic';\n  }\n  get schema() {\n    return {\n      parseDOM: [{\n        tag: 'i'\n      }, {\n        tag: 'em'\n      }, {\n        style: 'font-style=italic'\n      }],\n      toDOM: () => ['em', 0]\n    };\n  }\n  keys(_ref49) {\n    let {\n      type\n    } = _ref49;\n    return {\n      'Mod-i': toggleMark(type)\n    };\n  }\n  commands(_ref50) {\n    let {\n      type\n    } = _ref50;\n    return () => toggleMark(type);\n  }\n  inputRules(_ref51) {\n    let {\n      type\n    } = _ref51;\n    return [markInputRule(/(?:^|[^_])(_([^_]+)_)$/, type), markInputRule(/(?:^|[^*])(\\*([^*]+)\\*)$/, type)];\n  }\n  pasteRules(_ref52) {\n    let {\n      type\n    } = _ref52;\n    return [markPasteRule(/_([^_]+)_/g, type), markPasteRule(/\\*([^*]+)\\*/g, type)];\n  }\n}\nclass Link extends Mark {\n  get name() {\n    return 'link';\n  }\n  get defaultOptions() {\n    return {\n      openOnClick: true,\n      target: null\n    };\n  }\n  get schema() {\n    return {\n      attrs: {\n        href: {\n          default: null\n        },\n        target: {\n          default: null\n        }\n      },\n      inclusive: false,\n      parseDOM: [{\n        tag: 'a[href]',\n        getAttrs: dom => ({\n          href: dom.getAttribute('href'),\n          target: dom.getAttribute('target')\n        })\n      }],\n      toDOM: node => ['a', {\n        ...node.attrs,\n        rel: 'noopener noreferrer nofollow',\n        target: node.attrs.target || this.options.target\n      }, 0]\n    };\n  }\n  commands(_ref53) {\n    let {\n      type\n    } = _ref53;\n    return attrs => {\n      if (attrs.href) {\n        return updateMark(type, attrs);\n      }\n      return removeMark(type);\n    };\n  }\n  pasteRules(_ref54) {\n    let {\n      type\n    } = _ref54;\n    return [pasteRule(/https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b([-a-zA-Z0-9@:%_+.~#?&//=,()!]*)/gi, type, url => ({\n      href: url\n    }))];\n  }\n  get plugins() {\n    if (!this.options.openOnClick) {\n      return [];\n    }\n    return [new Plugin({\n      props: {\n        handleClick: (view, pos, event) => {\n          const {\n            schema\n          } = view.state;\n          const attrs = getMarkAttrs(view.state, schema.marks.link);\n          if (attrs.href && event.target instanceof HTMLAnchorElement) {\n            event.stopPropagation();\n            window.open(attrs.href, attrs.target);\n          }\n        }\n      }\n    })];\n  }\n}\nclass Strike extends Mark {\n  get name() {\n    return 'strike';\n  }\n  get schema() {\n    return {\n      parseDOM: [{\n        tag: 's'\n      }, {\n        tag: 'del'\n      }, {\n        tag: 'strike'\n      }, {\n        style: 'text-decoration',\n        getAttrs: value => value === 'line-through'\n      }],\n      toDOM: () => ['s', 0]\n    };\n  }\n  keys(_ref55) {\n    let {\n      type\n    } = _ref55;\n    return {\n      'Mod-d': toggleMark(type)\n    };\n  }\n  commands(_ref56) {\n    let {\n      type\n    } = _ref56;\n    return () => toggleMark(type);\n  }\n  inputRules(_ref57) {\n    let {\n      type\n    } = _ref57;\n    return [markInputRule(/~([^~]+)~$/, type)];\n  }\n  pasteRules(_ref58) {\n    let {\n      type\n    } = _ref58;\n    return [markPasteRule(/~([^~]+)~/g, type)];\n  }\n}\nclass Underline extends Mark {\n  get name() {\n    return 'underline';\n  }\n  get schema() {\n    return {\n      parseDOM: [{\n        tag: 'u'\n      }, {\n        style: 'text-decoration',\n        getAttrs: value => value === 'underline'\n      }],\n      toDOM: () => ['u', 0]\n    };\n  }\n  keys(_ref59) {\n    let {\n      type\n    } = _ref59;\n    return {\n      'Mod-u': toggleMark(type)\n    };\n  }\n  commands(_ref60) {\n    let {\n      type\n    } = _ref60;\n    return () => toggleMark(type);\n  }\n}\nclass Collaboration extends Extension {\n  get name() {\n    return 'collaboration';\n  }\n  init() {\n    this.getSendableSteps = this.debounce(state => {\n      const sendable = sendableSteps(state);\n      if (sendable) {\n        this.options.onSendable({\n          editor: this.editor,\n          sendable: {\n            version: sendable.version,\n            steps: sendable.steps.map(step => step.toJSON()),\n            clientID: sendable.clientID\n          }\n        });\n      }\n    }, this.options.debounce);\n    this.editor.on('transaction', _ref61 => {\n      let {\n        state\n      } = _ref61;\n      this.getSendableSteps(state);\n    });\n  }\n  get defaultOptions() {\n    return {\n      version: 0,\n      clientID: Math.floor(Math.random() * 0xFFFFFFFF),\n      debounce: 250,\n      onSendable: () => {},\n      update: _ref62 => {\n        let {\n          steps,\n          version\n        } = _ref62;\n        const {\n          state,\n          view,\n          schema\n        } = this.editor;\n        if (getVersion(state) > version) {\n          return;\n        }\n        view.dispatch(receiveTransaction(state, steps.map(item => Step.fromJSON(schema, item.step)), steps.map(item => item.clientID)));\n      }\n    };\n  }\n  get plugins() {\n    return [collab({\n      version: this.options.version,\n      clientID: this.options.clientID\n    })];\n  }\n  debounce(fn, delay) {\n    let timeout;\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n      timeout = setTimeout(() => {\n        fn(...args);\n        timeout = null;\n      }, delay);\n    };\n  }\n}\nclass Focus extends Extension {\n  get name() {\n    return 'focus';\n  }\n  get defaultOptions() {\n    return {\n      className: 'has-focus',\n      nested: false\n    };\n  }\n  get plugins() {\n    return [new Plugin({\n      props: {\n        decorations: _ref63 => {\n          let {\n            doc,\n            plugins,\n            selection\n          } = _ref63;\n          const editablePlugin = plugins.find(plugin => plugin.key.startsWith('editable$'));\n          const editable = editablePlugin.props.editable();\n          const active = editable && this.options.className;\n          const {\n            focused\n          } = this.editor;\n          const {\n            anchor\n          } = selection;\n          const decorations = [];\n          if (!active || !focused) {\n            return false;\n          }\n          doc.descendants((node, pos) => {\n            const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n            if (hasAnchor && !node.isText) {\n              const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                class: this.options.className\n              });\n              decorations.push(decoration);\n            }\n            return this.options.nested;\n          });\n          return DecorationSet.create(doc, decorations);\n        }\n      }\n    })];\n  }\n}\nclass History extends Extension {\n  get name() {\n    return 'history';\n  }\n  get defaultOptions() {\n    return {\n      depth: '',\n      newGroupDelay: ''\n    };\n  }\n  keys() {\n    const keymap = {\n      'Mod-z': undo,\n      'Mod-y': redo,\n      'Shift-Mod-z': redo,\n      // Russian language\n      'Mod-я': undo,\n      'Shift-Mod-я': redo\n    };\n    return keymap;\n  }\n  get plugins() {\n    return [history({\n      depth: this.options.depth,\n      newGroupDelay: this.options.newGroupDelay\n    })];\n  }\n  commands() {\n    return {\n      undo: () => undo,\n      redo: () => redo,\n      undoDepth: () => undoDepth,\n      redoDepth: () => redoDepth\n    };\n  }\n}\nclass Placeholder extends Extension {\n  get name() {\n    return 'placeholder';\n  }\n  get defaultOptions() {\n    return {\n      emptyEditorClass: 'is-editor-empty',\n      emptyNodeClass: 'is-empty',\n      emptyNodeText: 'Write something …',\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true\n    };\n  }\n  get plugins() {\n    return [new Plugin({\n      props: {\n        decorations: _ref64 => {\n          let {\n            doc,\n            plugins,\n            selection\n          } = _ref64;\n          const editablePlugin = plugins.find(plugin => plugin.key.startsWith('editable$'));\n          const editable = editablePlugin.props.editable();\n          const active = editable || !this.options.showOnlyWhenEditable;\n          const {\n            anchor\n          } = selection;\n          const decorations = [];\n          const isEditorEmpty = doc.textContent.length === 0;\n          if (!active) {\n            return false;\n          }\n          doc.descendants((node, pos) => {\n            const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n            const isNodeEmpty = node.content.size === 0;\n            if ((hasAnchor || !this.options.showOnlyCurrent) && isNodeEmpty) {\n              const classes = [this.options.emptyNodeClass];\n              if (isEditorEmpty) {\n                classes.push(this.options.emptyEditorClass);\n              }\n              const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                class: classes.join(' '),\n                'data-empty-text': typeof this.options.emptyNodeText === 'function' ? this.options.emptyNodeText(node) : this.options.emptyNodeText\n              });\n              decorations.push(decoration);\n            }\n            return false;\n          });\n          return DecorationSet.create(doc, decorations);\n        }\n      }\n    })];\n  }\n}\nclass Search extends Extension {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    this.results = [];\n    this.searchTerm = null;\n    this._updating = false;\n  }\n  get name() {\n    return 'search';\n  }\n  get defaultOptions() {\n    return {\n      autoSelectNext: true,\n      findClass: 'find',\n      searching: false,\n      caseSensitive: false,\n      disableRegex: true,\n      alwaysSearch: false\n    };\n  }\n  commands() {\n    return {\n      find: attrs => this.find(attrs),\n      replace: attrs => this.replace(attrs),\n      replaceAll: attrs => this.replaceAll(attrs),\n      clearSearch: () => this.clear()\n    };\n  }\n  get findRegExp() {\n    return RegExp(this.searchTerm, !this.options.caseSensitive ? 'gui' : 'gu');\n  }\n  get decorations() {\n    return this.results.map(deco => Decoration.inline(deco.from, deco.to, {\n      class: this.options.findClass\n    }));\n  }\n  _search(doc) {\n    this.results = [];\n    const mergedTextNodes = [];\n    let index = 0;\n    if (!this.searchTerm) {\n      return;\n    }\n    doc.descendants((node, pos) => {\n      if (node.isText) {\n        if (mergedTextNodes[index]) {\n          mergedTextNodes[index] = {\n            text: mergedTextNodes[index].text + node.text,\n            pos: mergedTextNodes[index].pos\n          };\n        } else {\n          mergedTextNodes[index] = {\n            text: node.text,\n            pos\n          };\n        }\n      } else {\n        index += 1;\n      }\n    });\n    mergedTextNodes.forEach(_ref65 => {\n      let {\n        text,\n        pos\n      } = _ref65;\n      const search = this.findRegExp;\n      let m; // eslint-disable-next-line no-cond-assign\n\n      while (m = search.exec(text)) {\n        if (m[0] === '') {\n          break;\n        }\n        this.results.push({\n          from: pos + m.index,\n          to: pos + m.index + m[0].length\n        });\n      }\n    });\n  }\n  replace(replace) {\n    return (state, dispatch) => {\n      const firstResult = this.results[0];\n      if (!firstResult) {\n        return;\n      }\n      const {\n        from,\n        to\n      } = this.results[0];\n      dispatch(state.tr.insertText(replace, from, to));\n      this.editor.commands.find(this.searchTerm);\n    };\n  }\n  rebaseNextResult(replace, index) {\n    let lastOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const nextIndex = index + 1;\n    if (!this.results[nextIndex]) {\n      return null;\n    }\n    const {\n      from: currentFrom,\n      to: currentTo\n    } = this.results[index];\n    const offset = currentTo - currentFrom - replace.length + lastOffset;\n    const {\n      from,\n      to\n    } = this.results[nextIndex];\n    this.results[nextIndex] = {\n      to: to - offset,\n      from: from - offset\n    };\n    return offset;\n  }\n  replaceAll(replace) {\n    return (_ref66, dispatch) => {\n      let {\n        tr\n      } = _ref66;\n      let offset;\n      if (!this.results.length) {\n        return;\n      }\n      this.results.forEach((_ref67, index) => {\n        let {\n          from,\n          to\n        } = _ref67;\n        tr.insertText(replace, from, to);\n        offset = this.rebaseNextResult(replace, index, offset);\n      });\n      dispatch(tr);\n      this.editor.commands.find(this.searchTerm);\n    };\n  }\n  find(searchTerm) {\n    return (state, dispatch) => {\n      this.searchTerm = this.options.disableRegex ? searchTerm.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&') : searchTerm;\n      this.updateView(state, dispatch);\n    };\n  }\n  clear() {\n    return (state, dispatch) => {\n      this.searchTerm = null;\n      this.updateView(state, dispatch);\n    };\n  }\n  updateView(_ref68, dispatch) {\n    let {\n      tr\n    } = _ref68;\n    this._updating = true;\n    dispatch(tr);\n    this._updating = false;\n  }\n  createDeco(doc) {\n    this._search(doc);\n    return this.decorations ? DecorationSet.create(doc, this.decorations) : [];\n  }\n  get plugins() {\n    return [new Plugin({\n      state: {\n        init() {\n          return DecorationSet.empty;\n        },\n        apply: (tr, old) => {\n          if (this._updating || this.options.searching || tr.docChanged && this.options.alwaysSearch) {\n            return this.createDeco(tr.doc);\n          }\n          if (tr.docChanged) {\n            return old.map(tr.mapping, tr.doc);\n          }\n          return old;\n        }\n      },\n      props: {\n        decorations(state) {\n          return this.getState(state);\n        }\n      }\n    })];\n  }\n}\nclass TrailingNode extends Extension {\n  get name() {\n    return 'trailing_node';\n  }\n  get defaultOptions() {\n    return {\n      node: 'paragraph',\n      notAfter: ['paragraph']\n    };\n  }\n  get plugins() {\n    const plugin = new PluginKey(this.name);\n    const disabledNodes = Object.entries(this.editor.schema.nodes).map(_ref69 => {\n      let [, value] = _ref69;\n      return value;\n    }).filter(node => this.options.notAfter.includes(node.name));\n    return [new Plugin({\n      key: plugin,\n      view: () => ({\n        update: view => {\n          const {\n            state\n          } = view;\n          const insertNodeAtEnd = plugin.getState(state);\n          if (!insertNodeAtEnd) {\n            return;\n          }\n          const {\n            doc,\n            schema,\n            tr\n          } = state;\n          const type = schema.nodes[this.options.node];\n          const transaction = tr.insert(doc.content.size, type.create());\n          view.dispatch(transaction);\n        }\n      }),\n      state: {\n        init: (_, state) => {\n          const lastNode = state.tr.doc.lastChild;\n          return !nodeEqualsType({\n            node: lastNode,\n            types: disabledNodes\n          });\n        },\n        apply: (tr, value) => {\n          if (!tr.docChanged) {\n            return value;\n          }\n          const lastNode = tr.doc.lastChild;\n          return !nodeEqualsType({\n            node: lastNode,\n            types: disabledNodes\n          });\n        }\n      }\n    })];\n  }\n}\nexport { Blockquote, Bold, BulletList, Code, CodeBlock, CodeBlockHighlight, Collaboration, Focus, HardBreak, Heading, HighlightPlugin as Highlight, History, HorizontalRule, Image, Italic, Link, ListItem, Mention, OrderedList, Placeholder, Search, Strike, SuggestionsPlugin as Suggestions, Table, TableCell, TableHeader, TableRow, TodoItem, TodoList, TrailingNode, Underline };","map":{"version":3,"names":["Node","Plugin","PluginKey","Mark","Extension","toggleWrap","wrappingInputRule","toggleList","toggleBlockType","setBlockType","textblockTypeInputRule","chainCommands","exitCode","nodeInputRule","splitListItem","sinkListItem","liftListItem","insertText","replaceText","splitToDefaultListItem","toggleMark","markInputRule","markPasteRule","updateMark","removeMark","pasteRule","low","DecorationSet","Decoration","findBlockNodes","createTable","getMarkAttrs","nodeEqualsType","Fragment","Plugin$1","PluginKey$1","TextSelection","tableNodes","addColumnBefore","addColumnAfter","deleteColumn","addRowBefore","addRowAfter","deleteRow","deleteTable","mergeCells","splitCell","toggleHeaderColumn","toggleHeaderRow","toggleHeaderCell","setCellAttr","fixTables","goToNextCell","columnResizing","tableEditing","Step","sendableSteps","getVersion","receiveTransaction","collab","history","undo","redo","undoDepth","redoDepth","Blockquote","name","schema","content","group","defining","draggable","parseDOM","tag","toDOM","commands","_ref","type","keys","_ref2","inputRules","_ref3","BulletList","_ref4","nodes","list_item","_ref5","_ref6","CodeBlock","marks","code","preserveWhitespace","_ref7","paragraph","_ref8","_ref9","getDecorations","_ref10","doc","decorations","blocks","filter","item","node","flatten","list","reduce","a","b","concat","Array","isArray","parseNodes","className","arguments","length","undefined","map","classes","properties","children","text","value","forEach","block","startPos","pos","highlightAuto","textContent","from","to","decoration","inline","class","join","push","create","HighlightPlugin","_ref11","state","init","_","_ref12","apply","transaction","decorationSet","oldState","newState","oldNodeName","selection","$head","parent","newNodeName","oldNodes","newNodes","docChanged","includes","mapping","props","getState","CodeBlockHighlight","constructor","options","Object","entries","languages","_ref13","registerLanguage","err","Error","defaultOptions","_ref14","_ref15","_ref16","plugins","HardBreak","selectable","_ref17","dispatch","tr","replaceSelectionWith","scrollIntoView","_ref18","command","Heading","levels","attrs","level","default","_ref19","_ref20","items","_ref21","RegExp","HorizontalRule","_ref22","_ref23","IMAGE_INPUT_REGEX","Image","src","alt","title","getAttrs","dom","getAttribute","_ref24","position","$cursor","$to","insert","_ref25","match","handleDOMEvents","drop","view","event","hasFiles","dataTransfer","files","images","file","test","preventDefault","coordinates","posAtCoords","left","clientX","top","clientY","image","reader","FileReader","onload","readerEvent","target","result","readAsDataURL","ListItem","_ref26","Enter","Tab","getTextBetween","blockSeparator","inlineSeparator","leafText","blockSeparated","inlineNode","nodesBetween","innerNode","isText","slice","Math","max","isLeaf","isInline","isBlock","triggerCharacter","_ref27","char","allowSpaces","startOfLine","$position","depth","escapedChar","suffix","prefix","regexp","textFrom","before","textTo","end","exec","matchPrefix","input","index","start","range","query","SuggestionsPlugin","_ref28","matcher","appendText","suggestionClass","onEnter","onChange","onExit","onKeyDown","onFilter","searchItems","JSON","stringify","toLowerCase","key","update","prevState","prev","next","moved","active","started","stopped","changed","handleStart","handleChange","handleExit","decorationNode","document","querySelector","decorationId","virtualNode","getBoundingClientRect","clientWidth","clientHeight","_ref29","$from","random","toString","substr","handleKeyDown","editorState","nodeName","Mention","mentionClass","getLabel","innerText","split","createFragment","label","fromJSON","insertMention","nodeType","nodeFragment","id","atom","getContent","_ref30","_ref31","OrderedList","order","hasAttribute","_ref32","_ref33","_ref34","childCount","TableNodes","tableGroup","cellContent","cellAttributes","background","getFromDOM","style","backgroundColor","setDOMAttr","assign","Table","resizable","table","_ref35","_ref36","rowsCount","colsCount","withHeaderRow","offset","anchor","resolvedPos","resolve","setSelection","near","toggleCellMerge","_ref37","TableHeader","table_header","TableCell","table_cell","TableRow","table_row","TodoItem","nested","methods","updateAttrs","done","template","contenteditable","priority","_ref38","TodoList","_ref39","todo_item","_ref40","Bold","fontWeight","_ref41","_ref42","_ref43","pasteRules","_ref44","Code","excludes","_ref45","_ref46","_ref47","_ref48","Italic","_ref49","_ref50","_ref51","_ref52","Link","openOnClick","href","inclusive","rel","_ref53","_ref54","url","handleClick","link","HTMLAnchorElement","stopPropagation","window","open","Strike","_ref55","_ref56","_ref57","_ref58","Underline","_ref59","_ref60","Collaboration","getSendableSteps","debounce","sendable","onSendable","editor","version","steps","step","toJSON","clientID","on","_ref61","floor","_ref62","fn","delay","timeout","_len","args","_key","clearTimeout","setTimeout","Focus","_ref63","editablePlugin","find","plugin","startsWith","editable","focused","descendants","hasAnchor","nodeSize","History","newGroupDelay","keymap","Placeholder","emptyEditorClass","emptyNodeClass","emptyNodeText","showOnlyWhenEditable","showOnlyCurrent","_ref64","isEditorEmpty","isNodeEmpty","size","Search","results","searchTerm","_updating","autoSelectNext","findClass","searching","caseSensitive","disableRegex","alwaysSearch","replace","replaceAll","clearSearch","clear","findRegExp","deco","_search","mergedTextNodes","_ref65","search","m","firstResult","rebaseNextResult","lastOffset","nextIndex","currentFrom","currentTo","_ref66","_ref67","updateView","_ref68","createDeco","empty","old","TrailingNode","notAfter","disabledNodes","_ref69","insertNodeAtEnd","lastNode","lastChild","types","Highlight","Suggestions"],"sources":["/Users/xander/go/hexon/frontend/node_modules/tiptap-extensions/dist/extensions.esm.js"],"sourcesContent":["\n    /*!\n    * tiptap-extensions v1.35.1\n    * (c) 2021 überdosis GbR (limited liability)\n    * @license MIT\n    */\n  \nimport { Node, Plugin, PluginKey, Mark, Extension } from 'tiptap';\nimport { toggleWrap, wrappingInputRule, toggleList, toggleBlockType, setBlockType, textblockTypeInputRule, chainCommands, exitCode, nodeInputRule, splitListItem, sinkListItem, liftListItem, insertText, replaceText, splitToDefaultListItem, toggleMark, markInputRule, markPasteRule, updateMark, removeMark, pasteRule } from 'tiptap-commands';\nimport low from 'lowlight/lib/core';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\nimport { findBlockNodes, createTable, getMarkAttrs, nodeEqualsType } from 'tiptap-utils';\nimport { Fragment } from 'prosemirror-model';\nimport { Plugin as Plugin$1, PluginKey as PluginKey$1, TextSelection } from 'prosemirror-state';\nimport { tableNodes, addColumnBefore, addColumnAfter, deleteColumn, addRowBefore, addRowAfter, deleteRow, deleteTable, mergeCells, splitCell, toggleHeaderColumn, toggleHeaderRow, toggleHeaderCell, setCellAttr, fixTables, goToNextCell, columnResizing, tableEditing } from 'prosemirror-tables';\nimport { Step } from 'prosemirror-transform';\nimport { sendableSteps, getVersion, receiveTransaction, collab } from 'prosemirror-collab';\nimport { history, undo, redo, undoDepth, redoDepth } from 'prosemirror-history';\n\nclass Blockquote extends Node {\n  get name() {\n    return 'blockquote';\n  }\n\n  get schema() {\n    return {\n      content: 'block*',\n      group: 'block',\n      defining: true,\n      draggable: false,\n      parseDOM: [{\n        tag: 'blockquote'\n      }],\n      toDOM: () => ['blockquote', 0]\n    };\n  }\n\n  commands({\n    type\n  }) {\n    return () => toggleWrap(type);\n  }\n\n  keys({\n    type\n  }) {\n    return {\n      'Ctrl->': toggleWrap(type)\n    };\n  }\n\n  inputRules({\n    type\n  }) {\n    return [wrappingInputRule(/^\\s*>\\s$/, type)];\n  }\n\n}\n\nclass BulletList extends Node {\n  get name() {\n    return 'bullet_list';\n  }\n\n  get schema() {\n    return {\n      content: 'list_item+',\n      group: 'block',\n      parseDOM: [{\n        tag: 'ul'\n      }],\n      toDOM: () => ['ul', 0]\n    };\n  }\n\n  commands({\n    type,\n    schema\n  }) {\n    return () => toggleList(type, schema.nodes.list_item);\n  }\n\n  keys({\n    type,\n    schema\n  }) {\n    return {\n      'Shift-Ctrl-8': toggleList(type, schema.nodes.list_item)\n    };\n  }\n\n  inputRules({\n    type\n  }) {\n    return [wrappingInputRule(/^\\s*([-+*])\\s$/, type)];\n  }\n\n}\n\nclass CodeBlock extends Node {\n  get name() {\n    return 'code_block';\n  }\n\n  get schema() {\n    return {\n      content: 'text*',\n      marks: '',\n      group: 'block',\n      code: true,\n      defining: true,\n      draggable: false,\n      parseDOM: [{\n        tag: 'pre',\n        preserveWhitespace: 'full'\n      }],\n      toDOM: () => ['pre', ['code', 0]]\n    };\n  }\n\n  commands({\n    type,\n    schema\n  }) {\n    return () => toggleBlockType(type, schema.nodes.paragraph);\n  }\n\n  keys({\n    type\n  }) {\n    return {\n      'Shift-Ctrl-\\\\': setBlockType(type)\n    };\n  }\n\n  inputRules({\n    type\n  }) {\n    return [textblockTypeInputRule(/^```$/, type)];\n  }\n\n}\n\nfunction getDecorations({\n  doc,\n  name\n}) {\n  const decorations = [];\n  const blocks = findBlockNodes(doc).filter(item => item.node.type.name === name);\n\n  const flatten = list => list.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);\n\n  function parseNodes(nodes, className = []) {\n    return nodes.map(node => {\n      const classes = [...className, ...(node.properties ? node.properties.className : [])];\n\n      if (node.children) {\n        return parseNodes(node.children, classes);\n      }\n\n      return {\n        text: node.value,\n        classes\n      };\n    });\n  }\n\n  blocks.forEach(block => {\n    let startPos = block.pos + 1;\n    const nodes = low.highlightAuto(block.node.textContent).value;\n    flatten(parseNodes(nodes)).map(node => {\n      const from = startPos;\n      const to = from + node.text.length;\n      startPos = to;\n      return { ...node,\n        from,\n        to\n      };\n    }).forEach(node => {\n      const decoration = Decoration.inline(node.from, node.to, {\n        class: node.classes.join(' ')\n      });\n      decorations.push(decoration);\n    });\n  });\n  return DecorationSet.create(doc, decorations);\n}\n\nfunction HighlightPlugin({\n  name\n}) {\n  return new Plugin({\n    name: new PluginKey('highlight'),\n    state: {\n      init: (_, {\n        doc\n      }) => getDecorations({\n        doc,\n        name\n      }),\n      apply: (transaction, decorationSet, oldState, newState) => {\n        // TODO: find way to cache decorations\n        // https://discuss.prosemirror.net/t/how-to-update-multiple-inline-decorations-on-node-change/1493\n        const oldNodeName = oldState.selection.$head.parent.type.name;\n        const newNodeName = newState.selection.$head.parent.type.name;\n        const oldNodes = findBlockNodes(oldState.doc).filter(item => item.node.type.name === name);\n        const newNodes = findBlockNodes(newState.doc).filter(item => item.node.type.name === name); // Apply decorations if selection includes named node, or transaction changes named node.\n\n        if (transaction.docChanged && ([oldNodeName, newNodeName].includes(name) || newNodes.length !== oldNodes.length)) {\n          return getDecorations({\n            doc: transaction.doc,\n            name\n          });\n        }\n\n        return decorationSet.map(transaction.mapping, transaction.doc);\n      }\n    },\n    props: {\n      decorations(state) {\n        return this.getState(state);\n      }\n\n    }\n  });\n}\n\nclass CodeBlockHighlight extends Node {\n  constructor(options = {}) {\n    super(options);\n\n    try {\n      Object.entries(this.options.languages).forEach(([name, mapping]) => {\n        low.registerLanguage(name, mapping);\n      });\n    } catch (err) {\n      throw new Error('Invalid syntax highlight definitions: define at least one highlight.js language mapping');\n    }\n  }\n\n  get name() {\n    return 'code_block';\n  }\n\n  get defaultOptions() {\n    return {\n      languages: {}\n    };\n  }\n\n  get schema() {\n    return {\n      content: 'text*',\n      marks: '',\n      group: 'block',\n      code: true,\n      defining: true,\n      draggable: false,\n      parseDOM: [{\n        tag: 'pre',\n        preserveWhitespace: 'full'\n      }],\n      toDOM: () => ['pre', ['code', 0]]\n    };\n  }\n\n  commands({\n    type,\n    schema\n  }) {\n    return () => toggleBlockType(type, schema.nodes.paragraph);\n  }\n\n  keys({\n    type\n  }) {\n    return {\n      'Shift-Ctrl-\\\\': setBlockType(type)\n    };\n  }\n\n  inputRules({\n    type\n  }) {\n    return [textblockTypeInputRule(/^```$/, type)];\n  }\n\n  get plugins() {\n    return [HighlightPlugin({\n      name: this.name\n    })];\n  }\n\n}\n\nclass HardBreak extends Node {\n  get name() {\n    return 'hard_break';\n  }\n\n  get schema() {\n    return {\n      inline: true,\n      group: 'inline',\n      selectable: false,\n      parseDOM: [{\n        tag: 'br'\n      }],\n      toDOM: () => ['br']\n    };\n  }\n\n  commands({\n    type\n  }) {\n    return () => chainCommands(exitCode, (state, dispatch) => {\n      dispatch(state.tr.replaceSelectionWith(type.create()).scrollIntoView());\n      return true;\n    });\n  }\n\n  keys({\n    type\n  }) {\n    const command = chainCommands(exitCode, (state, dispatch) => {\n      dispatch(state.tr.replaceSelectionWith(type.create()).scrollIntoView());\n      return true;\n    });\n    return {\n      'Mod-Enter': command,\n      'Shift-Enter': command\n    };\n  }\n\n}\n\nclass Heading extends Node {\n  get name() {\n    return 'heading';\n  }\n\n  get defaultOptions() {\n    return {\n      levels: [1, 2, 3, 4, 5, 6]\n    };\n  }\n\n  get schema() {\n    return {\n      attrs: {\n        level: {\n          default: 1\n        }\n      },\n      content: 'inline*',\n      group: 'block',\n      defining: true,\n      draggable: false,\n      parseDOM: this.options.levels.map(level => ({\n        tag: `h${level}`,\n        attrs: {\n          level\n        }\n      })),\n      toDOM: node => [`h${node.attrs.level}`, 0]\n    };\n  }\n\n  commands({\n    type,\n    schema\n  }) {\n    return attrs => toggleBlockType(type, schema.nodes.paragraph, attrs);\n  }\n\n  keys({\n    type\n  }) {\n    return this.options.levels.reduce((items, level) => ({ ...items,\n      ...{\n        [`Shift-Ctrl-${level}`]: setBlockType(type, {\n          level\n        })\n      }\n    }), {});\n  }\n\n  inputRules({\n    type\n  }) {\n    return this.options.levels.map(level => textblockTypeInputRule(new RegExp(`^(#{1,${level}})\\\\s$`), type, () => ({\n      level\n    })));\n  }\n\n}\n\nclass HorizontalRule extends Node {\n  get name() {\n    return 'horizontal_rule';\n  }\n\n  get schema() {\n    return {\n      group: 'block',\n      parseDOM: [{\n        tag: 'hr'\n      }],\n      toDOM: () => ['hr']\n    };\n  }\n\n  commands({\n    type\n  }) {\n    return () => (state, dispatch) => dispatch(state.tr.replaceSelectionWith(type.create()));\n  }\n\n  inputRules({\n    type\n  }) {\n    return [nodeInputRule(/^(?:---|___\\s|\\*\\*\\*\\s)$/, type)];\n  }\n\n}\n\n/**\n * Matches following attributes in Markdown-typed image: [, alt, src, title]\n *\n * Example:\n * ![Lorem](image.jpg) -> [, \"Lorem\", \"image.jpg\"]\n * ![](image.jpg \"Ipsum\") -> [, \"\", \"image.jpg\", \"Ipsum\"]\n * ![Lorem](image.jpg \"Ipsum\") -> [, \"Lorem\", \"image.jpg\", \"Ipsum\"]\n */\n\nconst IMAGE_INPUT_REGEX = /!\\[(.+|:?)]\\((\\S+)(?:(?:\\s+)[\"'](\\S+)[\"'])?\\)/;\nclass Image extends Node {\n  get name() {\n    return 'image';\n  }\n\n  get schema() {\n    return {\n      inline: true,\n      attrs: {\n        src: {},\n        alt: {\n          default: null\n        },\n        title: {\n          default: null\n        }\n      },\n      group: 'inline',\n      draggable: true,\n      parseDOM: [{\n        tag: 'img[src]',\n        getAttrs: dom => ({\n          src: dom.getAttribute('src'),\n          title: dom.getAttribute('title'),\n          alt: dom.getAttribute('alt')\n        })\n      }],\n      toDOM: node => ['img', node.attrs]\n    };\n  }\n\n  commands({\n    type\n  }) {\n    return attrs => (state, dispatch) => {\n      const {\n        selection\n      } = state;\n      const position = selection.$cursor ? selection.$cursor.pos : selection.$to.pos;\n      const node = type.create(attrs);\n      const transaction = state.tr.insert(position, node);\n      dispatch(transaction);\n    };\n  }\n\n  inputRules({\n    type\n  }) {\n    return [nodeInputRule(IMAGE_INPUT_REGEX, type, match => {\n      const [, alt, src, title] = match;\n      return {\n        src,\n        alt,\n        title\n      };\n    })];\n  }\n\n  get plugins() {\n    return [new Plugin({\n      props: {\n        handleDOMEvents: {\n          drop(view, event) {\n            const hasFiles = event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length;\n\n            if (!hasFiles) {\n              return;\n            }\n\n            const images = Array.from(event.dataTransfer.files).filter(file => /image/i.test(file.type));\n\n            if (images.length === 0) {\n              return;\n            }\n\n            event.preventDefault();\n            const {\n              schema\n            } = view.state;\n            const coordinates = view.posAtCoords({\n              left: event.clientX,\n              top: event.clientY\n            });\n            images.forEach(image => {\n              const reader = new FileReader();\n\n              reader.onload = readerEvent => {\n                const node = schema.nodes.image.create({\n                  src: readerEvent.target.result\n                });\n                const transaction = view.state.tr.insert(coordinates.pos, node);\n                view.dispatch(transaction);\n              };\n\n              reader.readAsDataURL(image);\n            });\n          }\n\n        }\n      }\n    })];\n  }\n\n}\n\nclass ListItem extends Node {\n  get name() {\n    return 'list_item';\n  }\n\n  get schema() {\n    return {\n      content: 'paragraph block*',\n      defining: true,\n      draggable: false,\n      parseDOM: [{\n        tag: 'li'\n      }],\n      toDOM: () => ['li', 0]\n    };\n  }\n\n  keys({\n    type\n  }) {\n    return {\n      Enter: splitListItem(type),\n      Tab: sinkListItem(type),\n      'Shift-Tab': liftListItem(type)\n    };\n  }\n\n}\n\nfunction getTextBetween(node, from, to, blockSeparator, inlineSeparator, leafText = '\\0') {\n  let text = '';\n  let blockSeparated = true;\n  let inlineNode = null;\n  node.content.nodesBetween(from, to, (innerNode, pos) => {\n    if (innerNode.isText) {\n      if (inlineNode) {\n        inlineNode = null;\n        return;\n      }\n\n      text += innerNode.text.slice(Math.max(from, pos) - pos, to - pos);\n      blockSeparated = !blockSeparator;\n    } else if (innerNode.isLeaf && leafText) {\n      text += leafText;\n      blockSeparated = !blockSeparator;\n    } else if (innerNode.isInline && !innerNode.isLeaf) {\n      text += inlineSeparator;\n\n      if (innerNode.textContent) {\n        text += innerNode.textContent;\n        inlineNode = innerNode;\n      }\n\n      text += inlineSeparator;\n      blockSeparated = !blockSeparated;\n    } else if (!blockSeparated && innerNode.isBlock) {\n      text += blockSeparator;\n      blockSeparated = true;\n    }\n  }, 0);\n  return text;\n} // Create a matcher that matches when a specific character is typed. Useful for @mentions and #tags.\n\n\nfunction triggerCharacter({\n  char = '@',\n  allowSpaces = false,\n  startOfLine = false\n}) {\n  return $position => {\n    // cancel if top level node\n    if ($position.depth <= 0) {\n      return false;\n    } // Matching expressions used for later\n\n\n    const escapedChar = `\\\\${char}`;\n    const suffix = new RegExp(`\\\\s${escapedChar}$`);\n    const prefix = startOfLine ? '^' : '';\n    const regexp = allowSpaces ? new RegExp(`${prefix}${escapedChar}.*?(?=\\\\s${escapedChar}|$)`, 'gm') : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\\\s${escapedChar}]*`, 'gm'); // Lookup the boundaries of the current node\n\n    const textFrom = $position.before();\n    const textTo = $position.end();\n    const text = getTextBetween($position.doc, textFrom, textTo, '\\0', '\\0');\n    let match = regexp.exec(text);\n    let position;\n\n    while (match !== null) {\n      // JavaScript doesn't have lookbehinds; this hacks a check that first character is \" \"\n      // or the line beginning\n      const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);\n\n      if (/^[\\s\\0]?$/.test(matchPrefix)) {\n        // The absolute position of the match in the document\n        const from = match.index + $position.start();\n        let to = from + match[0].length; // Edge case handling; if spaces are allowed and we're directly in between\n        // two triggers\n\n        if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\n          match[0] += ' ';\n          to += 1;\n        } // If the $position is located within the matched substring, return that range\n\n\n        if (from < $position.pos && to >= $position.pos) {\n          position = {\n            range: {\n              from,\n              to\n            },\n            query: match[0].slice(char.length),\n            text: match[0]\n          };\n        }\n      }\n\n      match = regexp.exec(text);\n    }\n\n    return position;\n  };\n}\n\nfunction SuggestionsPlugin({\n  matcher = {\n    char: '@',\n    allowSpaces: false,\n    startOfLine: false\n  },\n  appendText = null,\n  suggestionClass = 'suggestion',\n  command = () => false,\n  items = [],\n  onEnter = () => false,\n  onChange = () => false,\n  onExit = () => false,\n  onKeyDown = () => false,\n  onFilter = (searchItems, query) => {\n    if (!query) {\n      return searchItems;\n    }\n\n    return searchItems.filter(item => JSON.stringify(item).toLowerCase().includes(query.toLowerCase()));\n  }\n}) {\n  return new Plugin$1({\n    key: new PluginKey$1('suggestions'),\n\n    view() {\n      return {\n        update: async (view, prevState) => {\n          const prev = this.key.getState(prevState);\n          const next = this.key.getState(view.state); // See how the state changed\n\n          const moved = prev.active && next.active && prev.range.from !== next.range.from;\n          const started = !prev.active && next.active;\n          const stopped = prev.active && !next.active;\n          const changed = !started && !stopped && prev.query !== next.query;\n          const handleStart = started || moved;\n          const handleChange = changed && !moved;\n          const handleExit = stopped || moved; // Cancel when suggestion isn't active\n\n          if (!handleStart && !handleChange && !handleExit) {\n            return;\n          }\n\n          const state = handleExit ? prev : next;\n          const decorationNode = document.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`); // build a virtual node for popper.js or tippy.js\n          // this can be used for building popups without a DOM node\n\n          const virtualNode = decorationNode ? {\n            getBoundingClientRect() {\n              return decorationNode.getBoundingClientRect();\n            },\n\n            clientWidth: decorationNode.clientWidth,\n            clientHeight: decorationNode.clientHeight\n          } : null;\n          const props = {\n            view,\n            range: state.range,\n            query: state.query,\n            text: state.text,\n            decorationNode,\n            virtualNode,\n            items: handleChange || handleStart ? await onFilter(Array.isArray(items) ? items : await items(), state.query) : [],\n            command: ({\n              range,\n              attrs\n            }) => {\n              command({\n                range,\n                attrs,\n                schema: view.state.schema\n              })(view.state, view.dispatch, view);\n\n              if (appendText) {\n                insertText(appendText)(view.state, view.dispatch, view);\n              }\n            }\n          }; // Trigger the hooks when necessary\n\n          if (handleExit) {\n            onExit(props);\n          }\n\n          if (handleChange) {\n            onChange(props);\n          }\n\n          if (handleStart) {\n            onEnter(props);\n          }\n        }\n      };\n    },\n\n    state: {\n      // Initialize the plugin's internal state.\n      init() {\n        return {\n          active: false,\n          range: {},\n          query: null,\n          text: null\n        };\n      },\n\n      // Apply changes to the plugin state from a view transaction.\n      apply(tr, prev) {\n        const {\n          selection\n        } = tr;\n        const next = { ...prev\n        }; // We can only be suggesting if there is no selection\n\n        if (selection.from === selection.to) {\n          // Reset active state if we just left the previous suggestion range\n          if (selection.from < prev.range.from || selection.from > prev.range.to) {\n            next.active = false;\n          } // Try to match against where our cursor currently is\n\n\n          const $position = selection.$from;\n          const match = triggerCharacter(matcher)($position);\n          const decorationId = (Math.random() + 1).toString(36).substr(2, 5); // If we found a match, update the current state to show it\n\n          if (match) {\n            next.active = true;\n            next.decorationId = prev.decorationId ? prev.decorationId : decorationId;\n            next.range = match.range;\n            next.query = match.query;\n            next.text = match.text;\n          } else {\n            next.active = false;\n          }\n        } else {\n          next.active = false;\n        } // Make sure to empty the range if suggestion is inactive\n\n\n        if (!next.active) {\n          next.decorationId = null;\n          next.range = {};\n          next.query = null;\n          next.text = null;\n        }\n\n        return next;\n      }\n\n    },\n    props: {\n      // Call the keydown hook if suggestion is active.\n      handleKeyDown(view, event) {\n        const {\n          active,\n          range\n        } = this.getState(view.state);\n        if (!active) return false;\n        return onKeyDown({\n          view,\n          event,\n          range\n        });\n      },\n\n      // Setup decorator on the currently active suggestion.\n      decorations(editorState) {\n        const {\n          active,\n          range,\n          decorationId\n        } = this.getState(editorState);\n        if (!active) return null;\n        return DecorationSet.create(editorState.doc, [Decoration.inline(range.from, range.to, {\n          nodeName: 'span',\n          class: suggestionClass,\n          'data-decoration-id': decorationId\n        })]);\n      }\n\n    }\n  });\n}\n\nclass Mention extends Node {\n  get name() {\n    return 'mention';\n  }\n\n  get defaultOptions() {\n    return {\n      matcher: {\n        char: '@',\n        allowSpaces: false,\n        startOfLine: false\n      },\n      mentionClass: 'mention',\n      suggestionClass: 'mention-suggestion'\n    };\n  }\n\n  getLabel(dom) {\n    return dom.innerText.split(this.options.matcher.char).join('');\n  }\n\n  createFragment(schema, label) {\n    return Fragment.fromJSON(schema, [{\n      type: 'text',\n      text: `${this.options.matcher.char}${label}`\n    }]);\n  }\n\n  insertMention(range, attrs, schema) {\n    const nodeType = schema.nodes[this.name];\n    const nodeFragment = this.createFragment(schema, attrs.label);\n    return replaceText(range, nodeType, attrs, nodeFragment);\n  }\n\n  get schema() {\n    return {\n      attrs: {\n        id: {},\n        label: {}\n      },\n      group: 'inline',\n      inline: true,\n      content: 'text*',\n      selectable: false,\n      atom: true,\n      toDOM: node => ['span', {\n        class: this.options.mentionClass,\n        'data-mention-id': node.attrs.id\n      }, `${this.options.matcher.char}${node.attrs.label}`],\n      parseDOM: [{\n        tag: 'span[data-mention-id]',\n        getAttrs: dom => {\n          const id = dom.getAttribute('data-mention-id');\n          const label = this.getLabel(dom);\n          return {\n            id,\n            label\n          };\n        },\n        getContent: (dom, schema) => {\n          const label = this.getLabel(dom);\n          return this.createFragment(schema, label);\n        }\n      }]\n    };\n  }\n\n  commands({\n    schema\n  }) {\n    return attrs => this.insertMention(null, attrs, schema);\n  }\n\n  get plugins() {\n    return [SuggestionsPlugin({\n      command: ({\n        range,\n        attrs,\n        schema\n      }) => this.insertMention(range, attrs, schema),\n      appendText: ' ',\n      matcher: this.options.matcher,\n      items: this.options.items,\n      onEnter: this.options.onEnter,\n      onChange: this.options.onChange,\n      onExit: this.options.onExit,\n      onKeyDown: this.options.onKeyDown,\n      onFilter: this.options.onFilter,\n      suggestionClass: this.options.suggestionClass\n    })];\n  }\n\n}\n\nclass OrderedList extends Node {\n  get name() {\n    return 'ordered_list';\n  }\n\n  get schema() {\n    return {\n      attrs: {\n        order: {\n          default: 1\n        }\n      },\n      content: 'list_item+',\n      group: 'block',\n      parseDOM: [{\n        tag: 'ol',\n        getAttrs: dom => ({\n          order: dom.hasAttribute('start') ? +dom.getAttribute('start') : 1\n        })\n      }],\n      toDOM: node => node.attrs.order === 1 ? ['ol', 0] : ['ol', {\n        start: node.attrs.order\n      }, 0]\n    };\n  }\n\n  commands({\n    type,\n    schema\n  }) {\n    return () => toggleList(type, schema.nodes.list_item);\n  }\n\n  keys({\n    type,\n    schema\n  }) {\n    return {\n      'Shift-Ctrl-9': toggleList(type, schema.nodes.list_item)\n    };\n  }\n\n  inputRules({\n    type\n  }) {\n    return [wrappingInputRule(/^(\\d+)\\.\\s$/, type, match => ({\n      order: +match[1]\n    }), (match, node) => node.childCount + node.attrs.order === +match[1])];\n  }\n\n}\n\nvar TableNodes = tableNodes({\n  tableGroup: 'block',\n  cellContent: 'block+',\n  cellAttributes: {\n    background: {\n      default: null,\n\n      getFromDOM(dom) {\n        return dom.style.backgroundColor || null;\n      },\n\n      setDOMAttr(value, attrs) {\n        if (value) {\n          const style = {\n            style: `${attrs.style || ''}background-color: ${value};`\n          };\n          Object.assign(attrs, style);\n        }\n      }\n\n    }\n  }\n});\n\nclass Table extends Node {\n  get name() {\n    return 'table';\n  }\n\n  get defaultOptions() {\n    return {\n      resizable: false\n    };\n  }\n\n  get schema() {\n    return TableNodes.table;\n  }\n\n  commands({\n    schema\n  }) {\n    return {\n      createTable: ({\n        rowsCount,\n        colsCount,\n        withHeaderRow\n      }) => (state, dispatch) => {\n        const offset = state.tr.selection.anchor + 1;\n        const nodes = createTable(schema, rowsCount, colsCount, withHeaderRow);\n        const tr = state.tr.replaceSelectionWith(nodes).scrollIntoView();\n        const resolvedPos = tr.doc.resolve(offset);\n        tr.setSelection(TextSelection.near(resolvedPos));\n        dispatch(tr);\n      },\n      addColumnBefore: () => addColumnBefore,\n      addColumnAfter: () => addColumnAfter,\n      deleteColumn: () => deleteColumn,\n      addRowBefore: () => addRowBefore,\n      addRowAfter: () => addRowAfter,\n      deleteRow: () => deleteRow,\n      deleteTable: () => deleteTable,\n      toggleCellMerge: () => (state, dispatch) => {\n        if (mergeCells(state, dispatch)) {\n          return;\n        }\n\n        splitCell(state, dispatch);\n      },\n      mergeCells: () => mergeCells,\n      splitCell: () => splitCell,\n      toggleHeaderColumn: () => toggleHeaderColumn,\n      toggleHeaderRow: () => toggleHeaderRow,\n      toggleHeaderCell: () => toggleHeaderCell,\n      setCellAttr: ({\n        name,\n        value\n      }) => setCellAttr(name, value),\n      fixTables: () => fixTables\n    };\n  }\n\n  keys() {\n    return {\n      Tab: goToNextCell(1),\n      'Shift-Tab': goToNextCell(-1)\n    };\n  }\n\n  get plugins() {\n    return [...(this.options.resizable ? [columnResizing()] : []), tableEditing()];\n  }\n\n}\n\nclass TableHeader extends Node {\n  get name() {\n    return 'table_header';\n  }\n\n  get schema() {\n    return TableNodes.table_header;\n  }\n\n}\n\nclass TableCell extends Node {\n  get name() {\n    return 'table_cell';\n  }\n\n  get schema() {\n    return TableNodes.table_cell;\n  }\n\n}\n\nclass TableRow extends Node {\n  get name() {\n    return 'table_row';\n  }\n\n  get schema() {\n    return TableNodes.table_row;\n  }\n\n}\n\nclass TodoItem extends Node {\n  get name() {\n    return 'todo_item';\n  }\n\n  get defaultOptions() {\n    return {\n      nested: false\n    };\n  }\n\n  get view() {\n    return {\n      props: ['node', 'updateAttrs', 'view'],\n      methods: {\n        onChange() {\n          this.updateAttrs({\n            done: !this.node.attrs.done\n          });\n        }\n\n      },\n      template: `\n        <li :data-type=\"node.type.name\" :data-done=\"node.attrs.done.toString()\" data-drag-handle>\n          <span class=\"todo-checkbox\" contenteditable=\"false\" @click=\"onChange\"></span>\n          <div class=\"todo-content\" ref=\"content\" :contenteditable=\"view.editable.toString()\"></div>\n        </li>\n      `\n    };\n  }\n\n  get schema() {\n    return {\n      attrs: {\n        done: {\n          default: false\n        }\n      },\n      draggable: true,\n      content: this.options.nested ? '(paragraph|todo_list)+' : 'paragraph+',\n      toDOM: node => {\n        const {\n          done\n        } = node.attrs;\n        return ['li', {\n          'data-type': this.name,\n          'data-done': done.toString()\n        }, ['span', {\n          class: 'todo-checkbox',\n          contenteditable: 'false'\n        }], ['div', {\n          class: 'todo-content'\n        }, 0]];\n      },\n      parseDOM: [{\n        priority: 51,\n        tag: `[data-type=\"${this.name}\"]`,\n        getAttrs: dom => ({\n          done: dom.getAttribute('data-done') === 'true'\n        })\n      }]\n    };\n  }\n\n  keys({\n    type\n  }) {\n    return {\n      Enter: splitToDefaultListItem(type),\n      Tab: this.options.nested ? sinkListItem(type) : () => {},\n      'Shift-Tab': liftListItem(type)\n    };\n  }\n\n}\n\nclass TodoList extends Node {\n  get name() {\n    return 'todo_list';\n  }\n\n  get schema() {\n    return {\n      group: 'block',\n      content: 'todo_item+',\n      toDOM: () => ['ul', {\n        'data-type': this.name\n      }, 0],\n      parseDOM: [{\n        priority: 51,\n        tag: `[data-type=\"${this.name}\"]`\n      }]\n    };\n  }\n\n  commands({\n    type,\n    schema\n  }) {\n    return () => toggleList(type, schema.nodes.todo_item);\n  }\n\n  inputRules({\n    type\n  }) {\n    return [wrappingInputRule(/^\\s*(\\[ \\])\\s$/, type)];\n  }\n\n}\n\nclass Bold extends Mark {\n  get name() {\n    return 'bold';\n  }\n\n  get schema() {\n    return {\n      parseDOM: [{\n        tag: 'strong'\n      }, {\n        tag: 'b',\n        getAttrs: node => node.style.fontWeight !== 'normal' && null\n      }, {\n        style: 'font-weight',\n        getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null\n      }],\n      toDOM: () => ['strong', 0]\n    };\n  }\n\n  keys({\n    type\n  }) {\n    return {\n      'Mod-b': toggleMark(type)\n    };\n  }\n\n  commands({\n    type\n  }) {\n    return () => toggleMark(type);\n  }\n\n  inputRules({\n    type\n  }) {\n    return [markInputRule(/(?:\\*\\*|__)([^*_]+)(?:\\*\\*|__)$/, type)];\n  }\n\n  pasteRules({\n    type\n  }) {\n    return [markPasteRule(/(?:\\*\\*|__)([^*_]+)(?:\\*\\*|__)/g, type)];\n  }\n\n}\n\nclass Code extends Mark {\n  get name() {\n    return 'code';\n  }\n\n  get schema() {\n    return {\n      excludes: '_',\n      parseDOM: [{\n        tag: 'code'\n      }],\n      toDOM: () => ['code', 0]\n    };\n  }\n\n  keys({\n    type\n  }) {\n    return {\n      'Mod-`': toggleMark(type)\n    };\n  }\n\n  commands({\n    type\n  }) {\n    return () => toggleMark(type);\n  }\n\n  inputRules({\n    type\n  }) {\n    return [markInputRule(/(?:`)([^`]+)(?:`)$/, type)];\n  }\n\n  pasteRules({\n    type\n  }) {\n    return [markPasteRule(/(?:`)([^`]+)(?:`)/g, type)];\n  }\n\n}\n\nclass Italic extends Mark {\n  get name() {\n    return 'italic';\n  }\n\n  get schema() {\n    return {\n      parseDOM: [{\n        tag: 'i'\n      }, {\n        tag: 'em'\n      }, {\n        style: 'font-style=italic'\n      }],\n      toDOM: () => ['em', 0]\n    };\n  }\n\n  keys({\n    type\n  }) {\n    return {\n      'Mod-i': toggleMark(type)\n    };\n  }\n\n  commands({\n    type\n  }) {\n    return () => toggleMark(type);\n  }\n\n  inputRules({\n    type\n  }) {\n    return [markInputRule(/(?:^|[^_])(_([^_]+)_)$/, type), markInputRule(/(?:^|[^*])(\\*([^*]+)\\*)$/, type)];\n  }\n\n  pasteRules({\n    type\n  }) {\n    return [markPasteRule(/_([^_]+)_/g, type), markPasteRule(/\\*([^*]+)\\*/g, type)];\n  }\n\n}\n\nclass Link extends Mark {\n  get name() {\n    return 'link';\n  }\n\n  get defaultOptions() {\n    return {\n      openOnClick: true,\n      target: null\n    };\n  }\n\n  get schema() {\n    return {\n      attrs: {\n        href: {\n          default: null\n        },\n        target: {\n          default: null\n        }\n      },\n      inclusive: false,\n      parseDOM: [{\n        tag: 'a[href]',\n        getAttrs: dom => ({\n          href: dom.getAttribute('href'),\n          target: dom.getAttribute('target')\n        })\n      }],\n      toDOM: node => ['a', { ...node.attrs,\n        rel: 'noopener noreferrer nofollow',\n        target: node.attrs.target || this.options.target\n      }, 0]\n    };\n  }\n\n  commands({\n    type\n  }) {\n    return attrs => {\n      if (attrs.href) {\n        return updateMark(type, attrs);\n      }\n\n      return removeMark(type);\n    };\n  }\n\n  pasteRules({\n    type\n  }) {\n    return [pasteRule(/https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b([-a-zA-Z0-9@:%_+.~#?&//=,()!]*)/gi, type, url => ({\n      href: url\n    }))];\n  }\n\n  get plugins() {\n    if (!this.options.openOnClick) {\n      return [];\n    }\n\n    return [new Plugin({\n      props: {\n        handleClick: (view, pos, event) => {\n          const {\n            schema\n          } = view.state;\n          const attrs = getMarkAttrs(view.state, schema.marks.link);\n\n          if (attrs.href && event.target instanceof HTMLAnchorElement) {\n            event.stopPropagation();\n            window.open(attrs.href, attrs.target);\n          }\n        }\n      }\n    })];\n  }\n\n}\n\nclass Strike extends Mark {\n  get name() {\n    return 'strike';\n  }\n\n  get schema() {\n    return {\n      parseDOM: [{\n        tag: 's'\n      }, {\n        tag: 'del'\n      }, {\n        tag: 'strike'\n      }, {\n        style: 'text-decoration',\n        getAttrs: value => value === 'line-through'\n      }],\n      toDOM: () => ['s', 0]\n    };\n  }\n\n  keys({\n    type\n  }) {\n    return {\n      'Mod-d': toggleMark(type)\n    };\n  }\n\n  commands({\n    type\n  }) {\n    return () => toggleMark(type);\n  }\n\n  inputRules({\n    type\n  }) {\n    return [markInputRule(/~([^~]+)~$/, type)];\n  }\n\n  pasteRules({\n    type\n  }) {\n    return [markPasteRule(/~([^~]+)~/g, type)];\n  }\n\n}\n\nclass Underline extends Mark {\n  get name() {\n    return 'underline';\n  }\n\n  get schema() {\n    return {\n      parseDOM: [{\n        tag: 'u'\n      }, {\n        style: 'text-decoration',\n        getAttrs: value => value === 'underline'\n      }],\n      toDOM: () => ['u', 0]\n    };\n  }\n\n  keys({\n    type\n  }) {\n    return {\n      'Mod-u': toggleMark(type)\n    };\n  }\n\n  commands({\n    type\n  }) {\n    return () => toggleMark(type);\n  }\n\n}\n\nclass Collaboration extends Extension {\n  get name() {\n    return 'collaboration';\n  }\n\n  init() {\n    this.getSendableSteps = this.debounce(state => {\n      const sendable = sendableSteps(state);\n\n      if (sendable) {\n        this.options.onSendable({\n          editor: this.editor,\n          sendable: {\n            version: sendable.version,\n            steps: sendable.steps.map(step => step.toJSON()),\n            clientID: sendable.clientID\n          }\n        });\n      }\n    }, this.options.debounce);\n    this.editor.on('transaction', ({\n      state\n    }) => {\n      this.getSendableSteps(state);\n    });\n  }\n\n  get defaultOptions() {\n    return {\n      version: 0,\n      clientID: Math.floor(Math.random() * 0xFFFFFFFF),\n      debounce: 250,\n      onSendable: () => {},\n      update: ({\n        steps,\n        version\n      }) => {\n        const {\n          state,\n          view,\n          schema\n        } = this.editor;\n\n        if (getVersion(state) > version) {\n          return;\n        }\n\n        view.dispatch(receiveTransaction(state, steps.map(item => Step.fromJSON(schema, item.step)), steps.map(item => item.clientID)));\n      }\n    };\n  }\n\n  get plugins() {\n    return [collab({\n      version: this.options.version,\n      clientID: this.options.clientID\n    })];\n  }\n\n  debounce(fn, delay) {\n    let timeout;\n    return function (...args) {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n\n      timeout = setTimeout(() => {\n        fn(...args);\n        timeout = null;\n      }, delay);\n    };\n  }\n\n}\n\nclass Focus extends Extension {\n  get name() {\n    return 'focus';\n  }\n\n  get defaultOptions() {\n    return {\n      className: 'has-focus',\n      nested: false\n    };\n  }\n\n  get plugins() {\n    return [new Plugin({\n      props: {\n        decorations: ({\n          doc,\n          plugins,\n          selection\n        }) => {\n          const editablePlugin = plugins.find(plugin => plugin.key.startsWith('editable$'));\n          const editable = editablePlugin.props.editable();\n          const active = editable && this.options.className;\n          const {\n            focused\n          } = this.editor;\n          const {\n            anchor\n          } = selection;\n          const decorations = [];\n\n          if (!active || !focused) {\n            return false;\n          }\n\n          doc.descendants((node, pos) => {\n            const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n\n            if (hasAnchor && !node.isText) {\n              const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                class: this.options.className\n              });\n              decorations.push(decoration);\n            }\n\n            return this.options.nested;\n          });\n          return DecorationSet.create(doc, decorations);\n        }\n      }\n    })];\n  }\n\n}\n\nclass History extends Extension {\n  get name() {\n    return 'history';\n  }\n\n  get defaultOptions() {\n    return {\n      depth: '',\n      newGroupDelay: ''\n    };\n  }\n\n  keys() {\n    const keymap = {\n      'Mod-z': undo,\n      'Mod-y': redo,\n      'Shift-Mod-z': redo,\n      // Russian language\n      'Mod-я': undo,\n      'Shift-Mod-я': redo\n    };\n    return keymap;\n  }\n\n  get plugins() {\n    return [history({\n      depth: this.options.depth,\n      newGroupDelay: this.options.newGroupDelay\n    })];\n  }\n\n  commands() {\n    return {\n      undo: () => undo,\n      redo: () => redo,\n      undoDepth: () => undoDepth,\n      redoDepth: () => redoDepth\n    };\n  }\n\n}\n\nclass Placeholder extends Extension {\n  get name() {\n    return 'placeholder';\n  }\n\n  get defaultOptions() {\n    return {\n      emptyEditorClass: 'is-editor-empty',\n      emptyNodeClass: 'is-empty',\n      emptyNodeText: 'Write something …',\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true\n    };\n  }\n\n  get plugins() {\n    return [new Plugin({\n      props: {\n        decorations: ({\n          doc,\n          plugins,\n          selection\n        }) => {\n          const editablePlugin = plugins.find(plugin => plugin.key.startsWith('editable$'));\n          const editable = editablePlugin.props.editable();\n          const active = editable || !this.options.showOnlyWhenEditable;\n          const {\n            anchor\n          } = selection;\n          const decorations = [];\n          const isEditorEmpty = doc.textContent.length === 0;\n\n          if (!active) {\n            return false;\n          }\n\n          doc.descendants((node, pos) => {\n            const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n            const isNodeEmpty = node.content.size === 0;\n\n            if ((hasAnchor || !this.options.showOnlyCurrent) && isNodeEmpty) {\n              const classes = [this.options.emptyNodeClass];\n\n              if (isEditorEmpty) {\n                classes.push(this.options.emptyEditorClass);\n              }\n\n              const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                class: classes.join(' '),\n                'data-empty-text': typeof this.options.emptyNodeText === 'function' ? this.options.emptyNodeText(node) : this.options.emptyNodeText\n              });\n              decorations.push(decoration);\n            }\n\n            return false;\n          });\n          return DecorationSet.create(doc, decorations);\n        }\n      }\n    })];\n  }\n\n}\n\nclass Search extends Extension {\n  constructor(options = {}) {\n    super(options);\n    this.results = [];\n    this.searchTerm = null;\n    this._updating = false;\n  }\n\n  get name() {\n    return 'search';\n  }\n\n  get defaultOptions() {\n    return {\n      autoSelectNext: true,\n      findClass: 'find',\n      searching: false,\n      caseSensitive: false,\n      disableRegex: true,\n      alwaysSearch: false\n    };\n  }\n\n  commands() {\n    return {\n      find: attrs => this.find(attrs),\n      replace: attrs => this.replace(attrs),\n      replaceAll: attrs => this.replaceAll(attrs),\n      clearSearch: () => this.clear()\n    };\n  }\n\n  get findRegExp() {\n    return RegExp(this.searchTerm, !this.options.caseSensitive ? 'gui' : 'gu');\n  }\n\n  get decorations() {\n    return this.results.map(deco => Decoration.inline(deco.from, deco.to, {\n      class: this.options.findClass\n    }));\n  }\n\n  _search(doc) {\n    this.results = [];\n    const mergedTextNodes = [];\n    let index = 0;\n\n    if (!this.searchTerm) {\n      return;\n    }\n\n    doc.descendants((node, pos) => {\n      if (node.isText) {\n        if (mergedTextNodes[index]) {\n          mergedTextNodes[index] = {\n            text: mergedTextNodes[index].text + node.text,\n            pos: mergedTextNodes[index].pos\n          };\n        } else {\n          mergedTextNodes[index] = {\n            text: node.text,\n            pos\n          };\n        }\n      } else {\n        index += 1;\n      }\n    });\n    mergedTextNodes.forEach(({\n      text,\n      pos\n    }) => {\n      const search = this.findRegExp;\n      let m; // eslint-disable-next-line no-cond-assign\n\n      while (m = search.exec(text)) {\n        if (m[0] === '') {\n          break;\n        }\n\n        this.results.push({\n          from: pos + m.index,\n          to: pos + m.index + m[0].length\n        });\n      }\n    });\n  }\n\n  replace(replace) {\n    return (state, dispatch) => {\n      const firstResult = this.results[0];\n\n      if (!firstResult) {\n        return;\n      }\n\n      const {\n        from,\n        to\n      } = this.results[0];\n      dispatch(state.tr.insertText(replace, from, to));\n      this.editor.commands.find(this.searchTerm);\n    };\n  }\n\n  rebaseNextResult(replace, index, lastOffset = 0) {\n    const nextIndex = index + 1;\n\n    if (!this.results[nextIndex]) {\n      return null;\n    }\n\n    const {\n      from: currentFrom,\n      to: currentTo\n    } = this.results[index];\n    const offset = currentTo - currentFrom - replace.length + lastOffset;\n    const {\n      from,\n      to\n    } = this.results[nextIndex];\n    this.results[nextIndex] = {\n      to: to - offset,\n      from: from - offset\n    };\n    return offset;\n  }\n\n  replaceAll(replace) {\n    return ({\n      tr\n    }, dispatch) => {\n      let offset;\n\n      if (!this.results.length) {\n        return;\n      }\n\n      this.results.forEach(({\n        from,\n        to\n      }, index) => {\n        tr.insertText(replace, from, to);\n        offset = this.rebaseNextResult(replace, index, offset);\n      });\n      dispatch(tr);\n      this.editor.commands.find(this.searchTerm);\n    };\n  }\n\n  find(searchTerm) {\n    return (state, dispatch) => {\n      this.searchTerm = this.options.disableRegex ? searchTerm.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&') : searchTerm;\n      this.updateView(state, dispatch);\n    };\n  }\n\n  clear() {\n    return (state, dispatch) => {\n      this.searchTerm = null;\n      this.updateView(state, dispatch);\n    };\n  }\n\n  updateView({\n    tr\n  }, dispatch) {\n    this._updating = true;\n    dispatch(tr);\n    this._updating = false;\n  }\n\n  createDeco(doc) {\n    this._search(doc);\n\n    return this.decorations ? DecorationSet.create(doc, this.decorations) : [];\n  }\n\n  get plugins() {\n    return [new Plugin({\n      state: {\n        init() {\n          return DecorationSet.empty;\n        },\n\n        apply: (tr, old) => {\n          if (this._updating || this.options.searching || tr.docChanged && this.options.alwaysSearch) {\n            return this.createDeco(tr.doc);\n          }\n\n          if (tr.docChanged) {\n            return old.map(tr.mapping, tr.doc);\n          }\n\n          return old;\n        }\n      },\n      props: {\n        decorations(state) {\n          return this.getState(state);\n        }\n\n      }\n    })];\n  }\n\n}\n\nclass TrailingNode extends Extension {\n  get name() {\n    return 'trailing_node';\n  }\n\n  get defaultOptions() {\n    return {\n      node: 'paragraph',\n      notAfter: ['paragraph']\n    };\n  }\n\n  get plugins() {\n    const plugin = new PluginKey(this.name);\n    const disabledNodes = Object.entries(this.editor.schema.nodes).map(([, value]) => value).filter(node => this.options.notAfter.includes(node.name));\n    return [new Plugin({\n      key: plugin,\n      view: () => ({\n        update: view => {\n          const {\n            state\n          } = view;\n          const insertNodeAtEnd = plugin.getState(state);\n\n          if (!insertNodeAtEnd) {\n            return;\n          }\n\n          const {\n            doc,\n            schema,\n            tr\n          } = state;\n          const type = schema.nodes[this.options.node];\n          const transaction = tr.insert(doc.content.size, type.create());\n          view.dispatch(transaction);\n        }\n      }),\n      state: {\n        init: (_, state) => {\n          const lastNode = state.tr.doc.lastChild;\n          return !nodeEqualsType({\n            node: lastNode,\n            types: disabledNodes\n          });\n        },\n        apply: (tr, value) => {\n          if (!tr.docChanged) {\n            return value;\n          }\n\n          const lastNode = tr.doc.lastChild;\n          return !nodeEqualsType({\n            node: lastNode,\n            types: disabledNodes\n          });\n        }\n      }\n    })];\n  }\n\n}\n\nexport { Blockquote, Bold, BulletList, Code, CodeBlock, CodeBlockHighlight, Collaboration, Focus, HardBreak, Heading, HighlightPlugin as Highlight, History, HorizontalRule, Image, Italic, Link, ListItem, Mention, OrderedList, Placeholder, Search, Strike, SuggestionsPlugin as Suggestions, Table, TableCell, TableHeader, TableRow, TodoItem, TodoList, TrailingNode, Underline };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}